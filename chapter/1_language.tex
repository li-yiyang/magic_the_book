\chapter{Language and What I mean Language}

\begin{quotation}
  The fundamental aim in the linguistic analysis of a language L is to separate the grammatical sequences which are the sentences of L from the ungrammatical sequences which are not sentences of L. 
  The grammar of L will thus be a device that generates all of the grammatical sequences of L and none of the ungrammatical ones. \\

  Noam Chomsky - Syntactic Structures (2nd Edition) de Gruyter Mouton (2002)
\end{quotation}

因为我只是一个业余的爱好者, 所以对于计算机语言的思考本该不是我所能够发言的, 我只能做到一个将前人的思想和智慧做一个整理和转述而已. 并且我的理解不一定正确, 请见谅. \footnote{假如你觉得不够过瘾的话, 可以看看我的参考资料, 或者你觉得我在哪里有所不足的话, 欢迎指出. }

\section{Magic is Basic \footnote{我记得阿瑟克拉克曾经说过, 一切科技发展到了一定程度都会像是魔法一样. 这样的原因究竟是因为科技发展得太过高级和复杂呢? 还是因为科技的使用的过程中存在着抽象的构造, 导致了人们不需要了解科技内部的构造和原理, 所以导致了使用过程中的无意识呢? 我说不清楚. \\ 虽然抽象的方式可以使用简单的原理构造出复杂的过程, 也可以将复杂的过程抽象为简单的过程, 这样让使用者可以轻松地使用, 也会导致使用者可能会盲目地使用, 最终失去了对技术的理解而变成了像是面对魔法一样的敬畏和恐惧. \\ 但是我认为, 哪怕是魔法, 也是有吟唱的技术的, 出了错的话就会爆炸之类的. 所以我们完全没必要神话技术, 只需要找到技术背后的计算过程的一些简单的原理, 我们就能够理解并实现最后的咒术吟唱. 然后成为大魔法师. 所以魔法是很简单的, 科技也是如此, 其实是一种每个人都能掌握的技术. }}
\begin{quotation}
  心智的活动, 除了尽力产生各种简单的认识之外, 主要表现在如下三个方面: \\
  1) 将若干简单认识组合为一个复合认识, 由此产生出各种复杂的认识. \\
  2) 将两个认识放在一起对照. 不管它们如何简单或者复杂. 在这样做时并不将它们合而为一. 由此得到有关它们的相互关系的认识. \\
  3) 将有关认识与那些在实际中和它们同在的所有其他认识隔离开. 这就是抽象. 所有具有普遍性的认识都是这样得到的. \\

  John Locke - An Essay Concerning Himan Understanding (1690)\footnote{来自SICP. 一本我觉得很好的书. }
\end{quotation}

\subsection{Intro: Once upon a Time}
回忆小学学习算术的过程: 老师亲切地站在讲台上, 告诉下面的一帮小屁孩, 同学们, 你们看, $1 + 2$ 就是把 $1$ 加上 $2$, 然后就是 $3$. \footnote{具体的到底有没有说是一个手指加上两个手指就是$3$, 还是一个苹果加上两个苹果就是三个苹果什么的, 我已经完全记不得了. 但是这个时候假如有个天赋异禀的小孩子说了一句, 老师, 我还知道$2+1=1+2$因为这个关于加法组成一个Abel交换群. 害, 一个法国数学笑话了. }我们就不解释这个加法的过程了, (很遗憾, 我也不得不默认你们知道一些东西, 像那些一般的教材一样为了简洁而略去许多的说明), 如果只是形式地看看这个算式的话: \footnote{下面的例子来源于王垠的\href{http://www.yinwang.org/blog-cn/2018/04/13/computer-science}{博客}, 里面的东西比我的要多, 并且我觉得写得比较有意思. }

$$ 1 + 2 $$

我们会发现, 这个算式有着这样的结构: 符号$+$将它左边的东西, 不管是什么, 和右边的东西加在一起, 然后得到了一个值(在这里就是$3$). 

然后, 我们会接触到更加复杂的数学表达式, 比如: 

$$1 + 2 \times (3 + 4 / 2)$$

这个公式计算肯定是不太麻烦的, 但是如果我们不在乎这个公式到底在做什么, 而是形式上的思考这个公式的形式结构, (为了减少计算符号的优先级, 我们可以将这个公式加上括号来看): 

$$1 + (2 \times (3 + (4 / 2)))$$

虽然这个公式非常的简单, 估计大多数的人都能一眼望穿, 但是请想想当年那个还在抠鼻屎玩的那个小屁孩, 小孩子接触到这个算式的时候是如何计算的? 大概是这样的一个过程: 

首先看到的是最外层的这个加号, 然后就要将$1$和括号的值加起来, 于是去计算括号, 也就是$2 \times (3 + (4 / 2))$的值, 然后就要将$2$和新的括号$(3 + (4 / 2))$的值乘起来, 于是为了计算$3 + (4 / 2)$的值, 继续往括号里面看... 如此往复, 直到到了最后一层的括号里面, 因为没有更深的括号了, 所以就只是一个简单的表达式, 可以进行简单的计算了. \footnote{这里我最近有一个想法, 就是是不是可以理解为我在看到优先级更高的计算的时候, 我将目前在做的事情先搁在一边, 类似于保存一个状态, 等到优先级更高的计算完成之后, 再回到原来的状态, 和新的结果进行一个运算, 相当于是推迟了计算. 有一个延时的感觉. }

于是我们计算出了最终的$4 / 2$的值$2$, 然后将这个值代回上一层的括号里面, 计算出$3 + 2$的值$5$, 然后计算$2 \times 5$的值$10$, 然后再计算$1 + 10$的值... \\

天呐, 原来口算竟然是这么复杂的一件事情吗? 看来我口算水平差也是情有可原了. 当然不是, 我们会发现, 第一步的过程, 也就是"看"表达式的过程, 在我们的大脑里面几乎是潜意识一般自动地处理的, 而第二步的算值的过程, 则不过是非常简单的两个数之间的四则运算而已. \footnote{相比对于四则运算你应该是没什么问题的了, 所以我们就将第二步的分析给略了先. }

在第一步的时候, 我们并不关心表达式的值, 而是关心表达式的形式结构, 然后在解构了表达式的形式结构之后, 我们得到了表达式的一个类似于下面的图形一样的逻辑结构: 

\begin{figure}[h]
  \centering
  \begin{tikzpicture}
    \tikzset{grow'=right,level distance=60pt}
    \tikzset{execute at begin node=\strut}
    \tikzset{every tree node/.style={anchor=base west}}
    \Tree [.Add [.Mutiply [.Add [.Divide [.4 ] [.2 ]] [.3 ]] [.2 ] ] [.1 ]]
  \end{tikzpicture}
  \caption{一个简单的图示}
\end{figure}

下面的例子虽然看起来非常"可怕"\footnote{其实不过就是一个极限的定义, 是从我的教科书上抄来的, 为了方便讲解}, 但是我们只会从形式上去看看这个东西, 所以不要害怕. 因为你会发现除了简单的加法, 一些复杂抽象的数学符号也是同样拥有着类似的形式结构(因为排版的缘故, 所以图跑了, 但是没关系, 翻到下一页就能够见到了. ): 

$$\forall \varepsilon > 0 (\exists N \in \mathbb{N} (\forall n > N \in \mathbb{N} (\vert a_n - a \vert < \varepsilon)))$$

\begin{figure}[h]
  \centering
  \begin{tikzpicture}
    \tikzset{grow'=right,level distance=60pt}
    \tikzset{execute at begin node=\strut}
    \tikzset{every tree node/.style={anchor=base west}}
    \Tree [.Forall [.Epsilon [.Greater [.Epsilon ] [.0 ]]] [.Exists [.N [.In [.Natural\ Number ]]] [.Forall [.n [.Greater [.n ] [.N ]]] [.Abs [.Sub [.an ] [.a ]] [.Epsilon ]]]]]
  \end{tikzpicture}
  \caption{还是一个简单的图示}
\end{figure}

这个东西虽然看起来好像是那么一回事, 但是在形式的分解下, 就会变成一堆非常简单的小关系, 或者是小逻辑, 小运算. 这样的分解就让我们能够理解和处理庞大的东西或者是抽象的东西. 

其实我认为不仅是学习算术的过程, 比如我们在日常表达的过程中, 或者是读一句话的时候, 我们也有类似的解析过程. 比如说下面这句话: 

\begin{quote}
  幸せな君の隣にいたいよ
\end{quote}

我们可以将这个句子分解成下面的结构\footnote{首先声明一下, 我不会日语, 我也不会什么语法分析, 也许以后会学, 但是现在不会, 这个可能只能算是我的一种瞎掰而已, 不过无伤大雅, 可以使用就好. }: \emph{((((幸せな)君)の)隣に)いたいよ}, 变成这样的结构之后, 每一个部分都不过是一个(看起来)简单的东西了. \footnote{然后在理解的时候, (有点像是上面的求值计算过程), 就会变成这样: ((((幸福的)你)的)身边)待着. 假如再加入一点点"达"的成分, 没准可以翻译成待在幸福的你的身边. 不过这个应该没关系了. 假如你觉得上面的例子有点不太过瘾, 你没准可以将这个模型应用到其他的语言里面, 虽然我不能保证一定适用但是我能够保证这个一定适用, 但是总归是一个有意思的思考方式. 并且我认为我的英语就是这么一个理解的过程的. 嗯, 加入以后有可能的话, 感觉可以试试往这个方向上做一些东西. }

那么这和计算机语言又有什么关系呢? 抖个机灵, 没关系, 因为世界上不存在所谓的计算机语言: 

\begin{quotation}
  My conscience won't let me call Ruby a \emph{computer} language. That would imply that the language works primarily on the computer's terms. That the language is designed to accommodate the computer, first and foremost. That therefore, we, the coders, are foreigners, seeking citizenship in the computer's locale. It's the computer's language and we are translators for the world. \\
  But what do you call the language when your brain begins to think in that language? When you start to use the language's own words and colloquialisms to express yourself. Say, the computer can't do that. How can it be the computer's language? It is ours, we speak it natively!\\
  We can no longer truthfully call it a \emph{computer} language. It is \emph{coderspeak}. It is the language of our thoughts.\\

  why the lucky stuff - \href{https://poignant.guide/book/chapter-3.html}{Why's (poignant) Guide to Ruby}
\end{quotation}

当然, 相比自然语言, 计算机语言为了方便计算机的理解, 它的结构形式就非常的明显并且简单, 比如经常被自己的圆括号表达形式而被嘲讽的Lisp语言, \footnote{有一个非常不恰当的比喻, 就是Lisp就像是中国的社会主义的思想是非常的美妙, 但是其他某些人说, 诶, 你好无聊啊, 有那么多括号, 你的形式好奇怪啊. 然后就被边缘化了. 然而很多语言都在"暗地"里学习Lisp的特性, 比如宏(marco), Lambda演算, eval等等. 因为感觉是真的香. }或者是形式比较单一呆板的汇编语言, \footnote{呃, 这个暂时不要求. 因为我认为学习汇编对理解计算机程序设计没有帮助. 但对理解计算机构造比较有用. 还是先学设计, 对文科生友好一点... }虽然它们的的形式结构虽然在某种程度上面给人一种不明觉厉的高级感, 但是假如你不要把它们想得那么复杂可怕, 其实编程语言就是这样的一个东西: 一种有着特定形式的语句, 按照这些语句所表现的一种结构能够用来描述逻辑过程. 就像是普通的汉语或者英语一样, 是用来描述或者表达一种过程的. 

本来到了这里我应该至少开始介绍一门编程语言了, 然后让你在计算机屏幕上面打印个什么, Hello World, 是吧? 然后让你乐乐, 觉得自己很厉害, 然后被我骗进来学一堆乱七八糟的东西, 最终成为掉头发的社畜. 呃, 我说了, 我只是一个业余爱好者, 并且我发现前面的风格如此随意, 就不太好突然降智, 画风突转什么的, 所以我打算把语言的介绍再往后推一点点. 就一点点. \footnote{可以去读一下why的书的第三章, 我最近会把它翻译掉. }

回到之前的小学算术题目: $(1 + (2 \times (3 + (4 / 2))))$, 假如我们已经分解好了结构, 那么每一次的计算只不过是加减乘除的最简单的操作了. 

计算机其实也就是这样的, 它能够做到的也就只有简单的计数和运算而已, 之所以能够实现那些像魔法一般的神奇的结果, 其背后也不过就是最简单的运算而已. 计算机在处理编程语言的时候会将它们分解成一定的结构, 然后再对那些最小的结构进行运算和处理. 

举一个例子: 

$$\sum_{i = 1}^5 i$$

假如我们不是伟大的高斯同学, 看到了这个$\sum$符号, 我们可能会把它看作是这样的东西: 对于每一个$i$从$1$到$5$, 将它们都加在一起. 对于人来说, 这很轻松: $1 + 2 + 3 + 4 + 5$, 虽然麻烦了一点. \footnote{传说是高斯同学在小学的时候发明了对这样的级数的求和公式. 但是我们不会这样来做. }

那么按照前面朴素的想法, 肯定会想要知道这个结构是什么样的呢? 没错, 就是: $(1 + (2 + (3 + (4 + (5)))))$. 假如我们是一个不那么聪明的计算机, 我们会这样做: 将$4 + 5$的结果和$3$相加, 然后将这个结果再和$2$相加... 虽然这个过程用语言来描述会又臭又长. 但是假如你写了很多的话, 就会发现好像这个过程有一定的规律: 将 什么 和 什么 相加, 这个相加的结果重新用来进行新的一轮的加法. 用语言来描述太复杂了, 用数学来表示: 

$$ sum(i) = sum(i - 1) + i , sum(1) = 1$$

这样的写法是不是比较抽象? 那么要不我们把它们替换看看? 

\begin{figure}[h]
  \centering
  \begin{tikzpicture}
    \tikzset{grow'=right,level distance=60pt}
    \tikzset{execute at begin node=\strut}
    \tikzset{every tree node/.style={anchor=base west}}
    \Tree [.sum(5) [.sum(4) [.sum(3) [.sum(2) [.1 ] [.2 ]] [.3 ]] [.4 ] ] [.5 ]]
  \end{tikzpicture}
  \caption{还是一个简单的图示}
\end{figure}

这样的展开的形式是不是就能够理解了? 每一次做的事情是不是就不过是加法而已? 并且假如你想要计算$\sum_{i = 1}^5 f(i)$的话, 是不是只需要将上面的数学公式描述改为$ sum(i) = sum(i - 1) + f(i) , sum(1) = f(1)$即可了? 假如你想要计算$\sum_{i = 1}^5000 f(i)$, 那么也非常轻松, 结果不就是$sum(5000)$嘛. 什么? 你问我结果是什么? 至少我是不会真的用手去算的. 我只会告诉你, $sum(5000)$就是一个这样的过程得到的结果: 这样的结果是将$f(i)$从$1$到$5000$的取值相加的过程的结果. \footnote{这里我觉得有必要来一点点的代码了: \mintinline{ruby}{def sum(i, f); i == 1 ? 1 : sum(i - 1, f) + f.call(i); end}. 之所以写成行的形式是因为我不知道怎么在注释里面写换行的代码. 但是我还是不开始讲编程语言, 诶, 就是玩. }

上面的过程里面, 我们做的事情就是将一个求和的过程来分解成一组计算机能够理解的简单过程. 这样的话, 我们就可以让计算机来为我们干活了. 不过可惜的是, 我们的数学语言和自然语言可能很难对计算机生效. 所以学习一点点的计算机语言有点必要了. 

\subsection{异乡人啊, 你的管风琴在唱着什么歌谣呢? }
\begin{quotation}
一日一夜に　月は照らずとも

悲傷しみに　鵺鳥鳴く

吾がかへり见すれど　花は散りぬべし

慰むる心は　消ぬるがごとく

新世に神集ひて　夜は明け鵺鳥鳴く

咲く花は　神に祈ひ禱む

生ける世に　我が身悲しも

夢は消ぬ　怨恨みて散る
\\
\emph{傀儡謠─怨恨みて散る} \footnote{来自我很喜欢的电影里面的音乐. \href{https://music.apple.com/cn/album/kugutsu-uta-uramite-chiru/1547968823}{Apple Music: Kugutsu Uta Uramite Chiru}. \\电影里面的故事比较有意思, 当虚假和现实难以区分的时候, 那么我们该对虚拟保持什么态度? 计算机技术其实已经发展到了能够实现电影里面哲思的地步了: 比如押井守(导演, 或者叫监督? )就认为手机就像是影片中的电子脑 -- 影片中的世界, 人们无法离开资讯世界与电子脑, 现实生活中, 人们也同样无法离开手机或者电脑, 或者说, 由它们组成的资讯的世界. 人与人之间的连接越来越多(lain), 但是连接的关系越来越脆弱... 就像是蜘蛛结网, 为了在摇曳的风中保持着网的完好, 不得不向四面八方射出自己的丝, 肚囊因此越来越扁. \\虚拟的困境在于其是转瞬即逝的. 这个无关技术是否先进. 我还记得蒋勋说红楼梦里面有一段故事, (大意) 讲的是一个大户人家, 千金小姐嫁人, 华贵的轿子在路上遇雨, 躲到和另一户贫穷人家的小轿子遇见了, 处于同情心, 她就将自己妈妈送给她的一个陪嫁品 -- 一个小小的像首饰盒一样的东西送给了那位穷小姐. 毕竟那个盒子看起来也十分不起眼. 然而命运多舛, 她嫁的家庭一瞬间荣华富贵全部消失, 自己也沦落一个普通的打杂的人, 在一家大户人家打工. 这家大户人家的主人有一间珍贵的阁楼, 不让任何人进去, 有一次这位曾经的千金小姐机缘巧合地走进了那间阁楼, 却突然发现里面供奉着的就是自己当初送给那位穷小姐的首饰盒 -- 原来那位穷小姐一家靠首饰盒里的财富做生意才发了家. 荣华富贵就是这样一瞬间来, 一瞬间去, 好像一切都是那么虚幻和飘渺, 转眼之间一切都改变了. \\啊, 好像有点偏离我们书本的内容了. }
\end{quotation}

这是一首日语的歌曲的歌词. 我摊牌了, 其实我不会日语, 所以下面的所有关于日语的语法的说法, 绝对是我的一己之见, 请学日语专业的同学饶过我. 但是没见过猪跑, 总是吃过猪肉的. 看到这么一串奇怪的东西, 你的眼睛(大概)肯定会想要去寻找你熟悉的汉字. 然后在这个过程中, 虽然这些汉字怪怪的, 但是你估计会下意识地将它们转换为简体字, 然后再尝试处理它们的意思. \footnote{这也是为什么我选择日语的原因, 因为它们借鉴了很多的中文, 假如直接放汉字的话, 就太容易识别了. 无法体现出我接下来讲的语法处理的过程. 又, 还有一个原因是因为日语和中文一样, 好像都是属于图形字符, 这也是为什么弹幕视频网站在中国和日本比较流行, 而在欧美国家很少. 因为英语之类的东西很难像汉字一样模糊地阅读. } 比如在"新世に神集ひて　夜は明け鵺鳥鳴く"一行里面, 我们可以先将那些词语进行一个替换(以及断句和联想): "新 世(界) * 神 (聚)集 * *  夜(晚) * 明(亮) * 鵺鸟\footnote{有说是一种妖怪, 也有说是一种画眉鸟的, 这我就没法说了. \href{https://zh.wikipedia.org/wiki/鵺}{维基百科}} 鸣(叫)". 

假如说我告诉你, 在日语里面的很多的语法结构有像这样的形式: 修饰 + 对象 + 动作. \footnote{注意, 这个语法说法是我杜撰出来的. 科不科学我不知道, 但是秉承着物理的不完全归纳法, 猜的厚脸皮我还是有的. \\ 其实之所以这样讲, 也是为了用来引出之后Ruby的语法: \mintinline{ruby}{UI::Button.new()}, 如果你会的话, 估计会觉得比较像. 没错, 就是因为我故意选的例子的原因. 这也是为什么你觉得很多教科书上的例题都很好, 然后实际拿来计算的时候就觉得不太对劲的原因之一吧. } 那么我们再用之前的结构的形式来给上面的那句话一个结构: (((新)(世界))(神)(聚集)), (((夜)(明))(鵺鸟)(鸣叫)). 这样的话, 根据结构代入那些小单元, 解释含义就能够得到语句的意思: (大概翻译) 新世界的神聚集, 夜明(黎明)时鵺鸟鸣叫. 
% \footnote{这样的解释我们不妨用Ruby的语法来进行一个比对: \mintinline{ruby}{新世界::神.聚集; 夜明::鵺鸟.鸣叫}, 这里我将\textbf{新世界}和\textbf{夜明}当作了一个命名空间, 然后\textbf{聚集}和\textbf{鸣叫}看成了类方法. 感觉写成\mintinline{ruby}{新世界::神.new.聚集; 夜明::鵺鸟.new.鸣叫}会更好一点. 不过其实都不是特别好就是了, 牵强附会的话总是有点困难, 还是再等等铺垫一个更好的出场机会吧. }

假如没有前面的一个分析过程, 直接遇到这样一个陌生的语言的文本, 哪怕是其中好像有一些熟悉的字眼, 可能也难以理解文本的意思吧. 那么思考里面的过程, 因为有了结构将语句分解成了简单的单元, 于是只需要理解简单的单元的含义, 就能够(通过结构)知道复杂语句的内容了. 并且这个时候文本中的熟悉的字眼就成为了辅助我们理解语句的工具了. 

其实对于一开始学习计算机语言的话, 我们还是先从形式上来理解语言, 这样的话, 我们就能够阅读. 这里建议阅读附录中对Why's (Poignant) Guide to Ruby中的部分翻译文字, 我会从别的角度来介绍形式. \footnote{之后我们会接触各种各样的语言, 也就会接触各种各样的形式. 不过和自然语言相比, 计算机语言因为是一种类似于人造的语言, 所以相比有着更多形式的, 更多语法的自然语言, 计算机语言的形式其实都是非常简单的. }

% 比如说: \footnote{下面的代码我不建议运行, 因为这些是我按照Ruby的形式和语法瞎写的乱七八糟的东西, 谁知道会不会出问题. 并且也不建议记住, 更不建议去背或者去死记具体函数的用法. 只要关注这个语言的形式. 并且联系我们之前对那段日语歌词的做法, 因为下一节才是真正开始教你一点点Ruby的时候, 现在还请忍耐一下, 关注其中的语言形式吧. }

Peter Norvig在其书PAIP中写道: "Learning a language involves remembering vocabulary items (or knowing where to look them up) as well as learning the basic rules for forming expressions and determining what they mean. " 在我读到这段话后, 我就决定按照这样的方法来展开我的书本. \footnote{其实why的书的做法就是这样的. }即, 我们先仅仅从形式的角度来观察语言. 而不必理解其中的太多的原理和含义. \footnote{如果你是一个实干派的话, 可以通过实际直接上手的方式来尝试里面的代码. 不过不一定都能够运行就是了. Ruby提供了一个叫做irb的环境来让人交互式地执行命令和计算过程. 相关的介绍在\href{https://li-yiyang.github.io/ruby/why's_(poignant)_guide_to_ruby/why's-poignant-guide/}{我的翻译}, 或者如果你不想安装的话, 通过\href{https://github.com/fkchang/opal-irb}{opal-irb}来尝试也不是不行. \\ 不过这里有一个非常愉快的建议: 假如你觉得不想看我啰啰嗦嗦写这么一大堆东西的话, 可以去查阅网络上的cheatsheet. (比如\href{https://www.codecademy.com/learn/learn-ruby/modules/learn-ruby-introduction-to-ruby-u/cheatsheet}{codecademy的cheatsheet}) 在之后我们遇到各种各样的编程语言的时候, 一般都会直接给出cheatsheet, 而不会像这样详细地介绍了, 毕竟学习的方法都是一样的. }

毕竟每一个方士做法的时候, 都要搭起法台, 做好仪式的形式工作. 并且形式的摆放有时候也能够产生巨大的作用. \footnote{"谓东方青帝灵威仰, 主春生. 南方赤帝赤熛怒, 主夏长. 西方白帝白招拒, 主秋成. 北方黑帝汁光纪, 主冬藏, 中央黄帝含枢纽, 则寄王四时. 以四时化育, 亦须土也. 更加昊天上帝耀魄宝, 则为六帝. " 摘自\emph{吕思勉《理学纲要》第二篇}} 那么没关系, 为了进入这个魔法世界, 所以我们还是先从形式上入手, 至少搭好一个作法的平台, 能够读懂前辈道士用魔法咒术的形式传来的Wi-Fi密码... 

\begin{quotation}
  \begin{minted}{ruby}
    (3 - 2) * (3 + 2)
    1 ** 3
    5 / 3
    5.0 / 3
  \end{minted}
\end{quotation}

这些数学运算大概是比较简单的吧? 加(+)减(-)乘(*)除(/)还有乘幂(**), 都是一些比较熟悉的操作, 并且和数学里面的运算优先级一样, 都是从左到右, 括号优先, 乘幂最大, 其次乘除, 最后加减. \footnote{唯一需要注意的是, Ruby在处理整数(Integer)的除法的时候, 会和C一样保留整数, 也就是说, \mintinline{ruby}{5 / 3} 会得到1, 而对于浮点数(Float, 或者可以理解为带小数位的数)参与的除法, 如\mintinline{ruby}{5.0 / 3}, 则会得到1.66666667类似这样的结果. 不过这些不是我们目前需要着急在意的事情, 这些只是出于设计考量而做的一些妥协而已. 是一种类似于约定主义的东西. 请把目光聚焦在这些表达式的形式上吧. }

倘若我们想要把数学运算的结果保留下来, 那么我们可能在计算器(以卡西欧fx-991CN X为例)上这样操作: \fbox{1} \fbox{+} \fbox{1} \fbox{STO} \fbox{x}, 于是我们就能够把$1 + 1$的计算结果储存到变量$x$中了. 那么在Ruby里面, 我们可以这样形式地记做: 

\begin{quotation}
  \begin{minted}{ruby}
    x = 1 + 1
    money = 100 * x
    lunch_fee = 50
    money = money - lunch_fee
  \end{minted}
\end{quotation}

并且就像是数学里面对变量的计算一样, 我们可以像这样用变量来计算. 不过是一个形式而已. 于是看到类似的结构之后, 我们不妨就理解为x is 1 + 1. 而在计算执行的过程中, 就像是从一个储存着变量值的地方将值取出, 然后放到相应的位置上进行计算. \footnote{那么具体是如何储存变量, 以及如何取出变量呢? 假如你并不了解所谓的寻址方法, 请构造一种方法通过变量名去访问变量值的方法. 请不必考虑计算机的结构限制, 你现在就是构造计算机的人. }

\begin{quotation}
  \begin{minted}{ruby}
    door = Door.new
    door.paint :red
    door.open
  \end{minted}
\end{quotation}

假如你会一点点英文的话, 上面那段文字估计就算不需要学计算机也是会的吧. \footnote{这个时候就可能会有人说, 啊, 少来了, 不过就是什么现在我们已经学会了1 + 1, 然后开始积分求和求累乘吧之类的. 呃, 怎么说呢, 还真是. 因为我觉得Ruby的很多美妙的操作是编程的程序员在相互维持着的, 比如那些很好看的method名字和很标准的ri文档, 这些虽然有Ruby本身的一些工具或者属性的夹持, 但是更多时候还是有赖于开发者的自觉. 比如要求良好的命名规范, 良好的注释, 以及duck philosophy(If something quarks like a duck, then treat it as a duck. )等等. 不过在自己写代码的时候可就不一定能够保证自己能够写出这样高质量的代码了, 所以假如你不注意的话, 就会写出一些看起来非常"极客"的东西: \mintinline{ruby}{var_0xfff.f_0x999.f_0x233 :aaza}. 假如还没有很好的排版(缩进)和注释, 就会导致整体的混乱以及难看. 不过嘛, 我们又不是什么自虐狂, 何必要这样折磨自己呢? 一般我们还是希望除了写代码的基本逻辑以外, 花一些时间和精力在美化代码, 或者让代码变得更加优雅之类的还是非常重要的. (虽然我觉得自己目前还没有那种能力... )\\不过也有因为这样导致的诟病, 比如说, 虽然和python很像, 但是python以其简洁和标准常常带来的是唯一的问题解决方案, 而Ruby却是写完了功能之后程序员为了追求奇技淫巧还在一直重构... 嘛, 没有什么好坏之分啦. }翻译翻译就是: door is a kind of Door. paint red to door. open the door. \footnote{虽然我突然发现日语的语序和这个真的是超级像诶: doorを赤く塗る, doorを開ける. }(door是一扇Door(门), door涂成了红色, door打开\footnote{这里我们就不要考虑什么主动型还是被动型了, 这点语法小问题而已, 宽容一点啦. })

这个时候我们相当于接触到了第一个在平时比较陌生, 但是在Ruby程序编程中的比较普遍存在的一种语言形式: \mintinline{ruby}{a.b(c)}. 这种形式在某种程度上可以说是Ruby的一个非常普遍存在的形式, 比如: 

\begin{quotation}
  \begin{minted}{ruby}
    player.move(:up, 1 * cm)
    player.attack :excalibur, enemy
    player.defence
  \end{minted}
\end{quotation}

上面那段有点像是一个RPG游戏了, player(玩家)在地图上向上走了1cm(厘米), player使用了excalibur(EX-咖喱棒)攻击enemy(敌人), player防御. 

如果仔细观察的话, 会发现这里的一些操作和上面的门的语句有一些十分类似的地方: 都是 \textbf{什么东西.做了什么动作(描述动作的一些信息)}, 或者是把括号去掉的形式. \footnote{这是因为Ruby比较灵活, 可以在它能够理解的范围内自动添加上括号. 但是假如会出现歧义的语句的时候, 就不能够这样忽略括号了, 否则会导致Ruby无法理解你想要表达的意思, 最后出错. }假如用一些专业一些的语言来说的话就是, 上面的语句的结构就是\textbf{对象.方法(方法参数)}. \footnote{英文的说法是\textbf{object.method(arguments)}, 其中方法的参数不一定只有一个, 并且也不一定只有特定的长度. }上面的"对象", "方法", "方法参数"我们不妨先采用形式化的定义而不是深究其具体的实现和原理. % 因为现在我们不要求理解这些的具体含义, 只要知道这样的形式以及其对应的一个名称, 以后解释的时候就会方便一点. 

有些时候, 虽然有时候会遇到某些看起来不像是满足上面的形式的代码, 这些代码其实是因为Ruby支持简化书写一小部分语法格式. \footnote{不知道这算不算是一种语法糖} 比如: 

\begin{quotation}
  \begin{minted}{ruby}
    print("I'm Groot. ")
    gets()
  \end{minted}
\end{quotation}

上面两个虽然看起来没有\mintinline{ruby}{a.b(c)}的形式, 但是假如将其完全书写, 就会发现其形式仍然是满足的. \\即 \mintinline{ruby}{Kernel.print("I'm Groot. ")}以及\mintinline{ruby}{Kernel.gets()}\footnote{Kernel是内核的一个意思. }的形式. 

我们传入的方法参数的形式有时候可以是空空如也的, 有时候可以是一连串的值, 有时候也可以是一些特殊的形式: 

\begin{quotation}
  \begin{minted}{ruby}
    5.times { print "I'm Lucky!!! " }
  \end{minted}
\end{quotation}

这句话有点像是: do the action of printing "I'm Lucky!!! " 5 times. (打印五次"I'm Lucky!!! ", 嗯, 人类的本质就是复读机. )

或者是: 

\begin{quotation}
  \begin{minted}{ruby}
    "I'm Lucky".each_char do |c|
      print c.upcase
    end
  \end{minted}
\end{quotation}

这句话就像是: do the action of printing the upper case of c, aka. each single character in the string "I'm Lucky". (取出"I'm Lucky"这串文字里面的每个字符, 简记为c, 将每个字符都以大写的方式打印到屏幕上去. )

也许你会觉得, 啊, 好麻烦啊, 上面两个例子又出现了一些新的形式, 这些形式好怪啊, 要学的东西好多啊. 还请不要怕, 其实我们并没有引入任何新的形式. 

其实在上面的代码中, 前半段的形式相比一定是让人十分眼熟的吧: \mintinline{ruby}{5.times}, \mintinline{ruby}{"I'm Lucky".each_char}就像是一种\mintinline{ruby}{a.b}的形式. 而后半段, 则出现了一个\textbf{do ... end}和\textbf{\{ ... \}}的形式. 这个时候, 我们不妨在形式上抽象地将其视为是一个整体, 就好像两者是一个特殊的"括号", "括号"里面包含了许多的内容. 这些内容具体是什么我们不必担心, 我们只需要像是对待字符串(一个被引号括起来的东西)一样, 对待这样的东西就好. 形式化地命名为代码块(block).

% 首先我们从至少还算是比较眼熟的部分开始看吧: \mintinline{ruby}{5.times}, \mintinline{ruby}{"I'm Lucky".each_char}其实和原来的object.method(arg)的形式是差不多的. 那么它们后面跟着的那一大块是什么? 假如我们不在意这个东西是什么的话, 但从形式上来看, 其实就是一个用\textbf{do ... end}包裹起来的一个东西, 里面好像填写了一些东西. 因为这样的结构比较独特, 并且有一定的意义, 我们以后就叫它代码块(block). 假如我们用一个名字(比如block)来替代这样的do ... end的组合块的话, 我们就会惊奇地发现, 其实这个的形式和我们之前看到的几乎是如出一辙的 -- \textbf{5.times block}. 是不是就像是把我们的代码块像参数一样传递给方法一样呢? 

所以我们在形式上就是这样理解的: 对于对象的某个方法, 我们传入了一个代码块来进行处理. \footnote{在ruby里面, 方法定义是这样形式记录的: \mintinline{ruby}{def method_name(param, *muti_param, &block)}, 我们的代码块用\textbf{block}标记, 不难发现其传入的形式就是用一个\textbf{\&}在前缀标记的. }

接着, 假如我们承认了这样的形式的话, 我们会发现, 数字和一个用引号包围的文本(字符串)也就是处于对象的一个位置, 那么从这个形式上猜测, 我们也不难说, 数字和字符串也不过是对象(object)罢了. \footnote{其实在Ruby里面, 所有东西都是对象, 并且所有的表达式都有返回值. 这个就是Ruby的一个核心的概念和特性. } 所以既然是对象, 就可以像我们之前一样的形式来处理和工作. 这就是一种形式而已. 

那么简单的分析我们就介绍到这里了. 总结一下: 

\begin{itemize}
  \item 在Ruby里面, 所有的东西都是对象(object), 所以处理起来的形式就像是\textbf{object.method(arg)}这样的形式. \footnote{比如四则运算的运算符, 其实也可以定义为\mintinline{ruby}{3.* 2}这样的形式, 只是为了方便人的阅读, 所以一般不会这样写而已; 或者是赋值语句, 也是内部有类似方法的定义的, 并且为了最后的美观提供了一个额外的写法而已. }
  % \item 在Ruby里面, 所有的表达式都有返回值. 
  \item 有一种叫做代码块(block)的东西, 通常出现的形式是\textbf{do ... end}的形式\footnote{也可以只是一对花括号\{\}, 这样的写法和 do 与 end是等价的, 只是在单行写起来会好看一点. }, 里面可以包一些"馅料"并传递给方法. 
\end{itemize}

那么在最后给出几个例子, 来结束我们这部分对简单的语句形式的介绍. \footnote{注意, 这里的语句形式实际上是体现了一种叫做面向对象编程的思想的东西. 但是并不是说我们必须要用面向对象编程的方式来进行编程. 并且我也不会强调面向对象的编程. 只是因为这样的介绍方法非常符合Ruby的思想: "所有东西都是对象". 并且这样的面向对象的编程方法比较容易让别人接受. }

\begin{example}
  请将下面的一些代码片段变成\mintinline{ruby}{a.b(c)}的形式: 
  首先是一个循环的代码: \footnote{这个东西可以写成这样的形式: \mintinline{ruby}{Kernel.loop(&block)}. 虽然看起来像是一种特殊结构, 但是实际上也是一种\mintinline{ruby}{a.b(c)}的形式啦. }
  \begin{minted}{ruby}
    loop do
      # ...
    end
  \end{minted}
  
  然后是一个更加普通的打印输出的代码: \footnote{可以写成这样的形式: \mintinline{ruby}{Kernel.puts(param)}}
  \begin{minted}{ruby}
    puts "How are you? "
  \end{minted}

  并且就像是之前的算数一样, 我们的这个形式也是可以堆叠起来形成一个更加复杂的结构的: 
  \begin{minted}{ruby}
    "(A) (good) (quote) (is) (something) (like) (this)".gsub("(", "").gsub(")", "").upcase
  \end{minted}

  这是因为在Ruby里面, 所有的表达式都有返回值, 于是语句前面的表达式的计算结果就会作为后面的表达式中的对象的身份来继续执行. 用括号来表示运算的优先级就像是: \mintinline{ruby}{(a.b(c)).d(e)}. 这样的话我们就拥有了通过简单的形式来构造复杂的语句的能力了. 
\end{example}

\begin{example}
  像之前的加法一样, 画出执行过程的分解, 比如上面嵌套的过程: 

  \begin{quotation}
    \begin{minted}{ruby}
      string.gsub("(", "").gsub(")", "").upcase
    \end{minted}
  \end{quotation}

  就可以写成: 

  \begin{figure}[h]
    \centering
    \begin{tikzpicture}
      \tikzset{grow'=right,level distance=60pt}
      \tikzset{execute at begin node=\strut}
      \tikzset{every tree node/.style={anchor=base west}}
      \Tree [.gsub [.gsub [.upcase ]]]
    \end{tikzpicture}
    \caption{虽然很短, 但是这是为了防止你觉得太简单}
  \end{figure}

  那么来点稍微给力点的: 

  \begin{quotation}
    \begin{minted}{ruby}
      puts("Hello, " + "cigaM ykcuL".reverse.upcase)
    \end{minted}
  \end{quotation}

  \begin{figure}[h]
    \centering
    \begin{tikzpicture}
      \tikzset{grow'=right,level distance=60pt}
      \tikzset{execute at begin node=\strut}
      \tikzset{every tree node/.style={anchor=base west}}
      \Tree [.puts [.add [.upcase .reverse .\text{"cigaM ykcuL"} ] [.\text{"Hello, "} ]]]
    \end{tikzpicture}
    \caption{执行的顺序是从右到左的, 请思考是为什么结构上看是从左到右的但是执行的顺序却相反. }\footnote{其实这和小学算术题是同样的原理, 比如我们在计算$1 - (2 + 3)$的时候, 在阅读的顺序上, 我们肯定会说减号在更加外面, 而加号更加内部, 但是括号的约定却是在内部的运算顺序优先于在外部的运算顺序. \\ 或者你也可以认为是, (我认为这样的理解会更有意思), 我们可以将括号看作是一个整体: $1 + x$, 其中$x$是一种有返回值的表达式. 于是在计算的过程中, 为了知道$x$的值, 就需要对$x$的表达式去进行求值, 将其返回值作为值来进行计算. }
  \end{figure}

  那么试着看看别的代码来理解它们形式和执行的意思吧, 这个时候, 你已经可以在形式上读懂很多的代码啦. (又是一个关于你已经学会了$1+1$了, 现在来看... 的笑话了. )
\end{example}

\subsection{特殊和一般的形式}
其实除了上面介绍的那种最最一般的形式, 在Ruby里面还有一些特殊的规则形式. 这些规则形式也许可能没有办法化简成普通的\mintinline{ruby}{a.b(c)}的形式, 所以会被Ruby特殊地去处理和执行. 我只会简单地介绍最常见的一些形式和规则, 然后在之后, 如果有需要的话, 再会增加介绍新的内容. 

\subsubsection*{数据形式和字面值}
\begin{quotation}
  \mintinline{ruby}{"#{title}の時間"}

  \emph{《3年E班》}
\end{quotation}

我们简单的赋值形式其实就算是一种比较特殊的形式了. 不过一个等号的形式如此简单... \footnote{其实也可以有一点点有意思的地方, 这个我会在后面写啦. 因为这个东西有的时候可以看作是\mintinline{ruby}{a.b(c)}的形式, 但是有的时候又不能够这样看. 虽然这样的不一致性让人很不爽, 但是我们还是先接受吧, 我会想想有没有一种好的方式来解决这个问题的. 虽然这个时候Lisp的列表的形式就看起来很香了. 因为解释起来非常便利, 即列表的第一个元素就是函数, 而其后面的都是函数的参数. } 那就暂时放过它吧. 

那么对于我们赋值的东西, 也就是数据. 正如前面我们看到的\mintinline{ruby}{1, 2, 3}, 以及\mintinline{ruby}{"文字"}之类的值的形式都是比较常见的数据的字面形式. 

比如说, 我们可能想要储存一个三年E班花名册, 但是这个时候, 使用变量的话, 就意味着我们可能需要这样命名: 

\begin{quotation}
  \begin{minted}{ruby}
    student_no_1 = "Akabane Karuma"
    # ...
    student_no_7 = "Kayano Kaede"
    # ...
    student_no_11 = "Shiota Nagisa"
    # ...
  \end{minted}
\end{quotation}

这样是不是太麻烦了呢? 没错, 所以Ruby中构造了一种叫做数组(Array)的数据类型, 让我们能够将一连串的数据储存组织在一起. \footnote{我们只会形式化地定义, 目前不会介绍如何具体实现. 后面会介绍如何实现. }

\begin{quotation}
  \begin{minted}{ruby}
    students = ["Akabane Karuma", "Kayano Kaede", "Shiota Nagisa"]
  \end{minted}
\end{quotation}

这个时候, 我们用方括号来表示边界, 然后在其中用逗号来区分两个不同的元素. 这个时候, 我们就定义了一个数组. 然后在访问的时候, 只需要告诉数组元素的位置, Ruby就会为我们去寻找相对应的值. \footnote{唉, 为什么这么想要知道怎么实现的呢? 好吧, 好吧. 我的答案是, 并没有一种绝对的实现方式, 比如说, 我们可以像C一样, 用针对寄存器的思考方式来实现: 通过设定基值和偏移量在地址上来寻找所对应的值. 但是我们又可以构造一个链表, 通过递归的方式来在列表上移动, 然后寻找所对应的值. 可是, 现在你知道了这些有什么用呢? 我觉得只会限制你的思想, 因为我觉得计算机就是一种约定主义: 如何通过约定的方式来约定一种结构才是比较有意思的东西. \\ 这个以后就体现了一种抽象的方式, 就像是在数学中, 我们定义了一种东西叫做集合. 对于集合的严格定义, 在使用的时候, 我们可以不必太过在意. 这就是一种抽象的概念. 但是这并不是说具体的实现和定义并不重要, 因为据我所知, 集合的定义也不是只有一种的, 比如\href{https://zh.wikipedia.org/wiki/公理化集合论}{ZF和ZFC集合论}.}

\begin{quotation}
  \begin{minted}{ruby}
    puts "Hello! " + students[0]
    puts "Good night. " + students[1]
  \end{minted}
\end{quotation}

唯一需要注意的是, 这里有一个关于计算机的笑话: 某些程序员数数的时候老是和别人差一, 因为他们都是从零开始数数的. 这是因为计算机是从零开始表示最开始的位置. 

但是有时候我们也会想要通过名字来访问, 就像是变量名字一样. 比如说我们想要一个字典, 对于输入的一个单词, 我们想要给出它的一个定义, 在形式上, 我们可以记作: 

\begin{quotation}
  \begin{minted}{ruby}
    dictionary = {
      "book" => "ほん", "Tao" => "道", "气" => "Qi", 
      "镜子" => "mirror", "つき" => "moon"
    }
  \end{minted}
\end{quotation}

我们把类似这样的形式叫做哈希(Hash). 其中我们会发现花括号的形式和之前的代码块的形式类似, 但是它们的含义并不一致(并且你也不能够用do..end来替换上面的形式, 尽管对代码块来说这样是可以的). 不过你可以理解为它们都表示了一大块的东西打包在一起的形式. 需要注意的是, 和数组的形式类似, 都是用逗号来分隔元素, 只是Hash中的元素是成对出现的而已. 并且上面的代码中的换行并不是必须的, 只是为了美观加入的. 

然后就能够用形式上处于\textbf{=>}前面的标记来访问箭头后面的标记了: \footnote{因为这样的形式, 所以我们常常把在前面的形式部分叫做key(键), 后面的叫做值(value). 就好像是拿钥匙去开锁, 对应的钥匙开对应的锁, 得到对应的数据. (或者是在钢琴上按键, 会弹奏出对应的音符. ), 我们会在后面介绍一下这个东西的原理. }

\begin{quotation}
  \begin{minted}{ruby}
    puts "The meaning of Tao is " + dictionary["Tao"]
    puts "And the meaning of book is " + dictionary["book"]
  \end{minted}
\end{quotation}

上面我们简单介绍了一些组织许多数据的方法. 这样的数据结构在大部分的编程语言中都有类似的实现. 比如Python中的元组, 列表, 字典之类的, C语言中的数组之类的. 这是因为Ruby从这些语言中吸取了经验. 最后介绍一种Ruby的数据表示形式: 符号(Symbol): \mintinline{ruby}{:this_is_a_simple}, 在形式上看起来, 符号就像是一种用冒号开头的没有引号的字符串. 在大部分情况下, 符号是用于表示一些方便区分名字, 但是这个名字不太需要编辑修改的问题. 

不过现在只需要知道, 这些数据对应的形式大概是这样的就足够了. \footnote{实际上我们的这些数据形式, 如果从数学上来看的话, 就像是一种单射. 将给定的(数组)位置或者(哈希)键作为原像, 映射到像上, 也就是我们这些数据结构中储存的内容. }

\subsubsection*{分支}
\begin{quotation}
  黄色的树林里分出两条路, 可惜我不能同时去涉足, 我在那路口久久伫立, 我向着一条路极目望去, 直到它消失在丛林深处。 但我却选了另外一条路, 它荒草萋萋, 十分幽寂, 显得更诱人, 更美丽, 虽然在这两条小路上, 都很少留下旅人的足迹, 虽然那天清晨落叶满地, 两条路都未经脚印污染. 呵, 留下一条路等改日再见! 但我知道路径延绵无尽头, 恐怕我难以再回返. 也许多少年后在某个地方, 我将轻声叹息把往事回顾, 一片树林里分出两条路, 而我选了人迹更少的一条, 从此决定了我一生的道路. 

  \emph{弗罗斯特《未选择的路》}
\end{quotation}

因为我的内心充满了欢喜, 所以我毅然走上了那条荆棘之路: 

\begin{quotation}
  \begin{minted}{ruby}
    go_to :muddy_road if heart.happy?
  \end{minted}
\end{quotation}

上面我们看到了一个稍微特殊一些的形式: \textbf{if}语句. 在形式上, 就像是一段过程跟着一个用if标记的标签. 就像是在林间出现了两条道路, 站在分支点上, 一个叫做if的木牌站在你的面前, 你献上了自己的condition(判断条件), 那块木牌在判断之后, 也许会在你献上的条件上盖上一个"合格", 然后让你走向快乐的餐桌之路. 但是同时也有可能会告诉你: "哦, 不, 你不合格! ", 然后把你赶到另外一个方向. \footnote{我们在这样的过程中, 就会需要做一件事: 跳过某一段过程代码, 即不执行该代码. 而执行某一段过程代码. 那么请思考如何构造类似的过程来实现这样类似的过程? \\ 这里有这样的一个朴素的想法, 我们可以把代码看作是放在图书馆里面的书本, 然后我们就像是一个图书管理员, 他是一个非常尽职尽责的图书管理员, 会仔细检查每一本书上的内容(每一步执行过程代码). 但是, 突然他看到了一本特殊的书 -- 书扉上写着: "哦, 我喜欢你, 假如你也喜欢我的话, 请到人文类E排18号的书架上的那本笔记上, 哪里有我的名字和信息. " 于是两厢情愿, 他走到了人文类E排18号的书架那, 第一次跳过了中间的一大段书没有检查. 而是从人文类E排18号开始继续检查书本了, 边检查, 边微笑... \\ 上面的过程给我们一个想法, 如果我们事先规定了所有的数据(代码)的位置, 然后我们就能够通过位置和标记来跳转. }

于是我们就会像这样写出我们的代码: 

\begin{quotation}
  \begin{minted}{ruby}
    if condition
      do_something_if_condition_is_true
    else
      do_otherthing_if_condition_is_false
    end
  \end{minted}
\end{quotation}

上面的这样两种形式就是if条件判断的两种形式: 行if和块if. 其中的\textbf{condition}就

\subsubsection*{为过程命名}
前面我们看到过了为值命名的变量, 其实不仅可以为值命名, 我们还能够为过程命名. 就好像是道士们口中念念有词, 召唤了一位金刚力士. 然后你就可以通过大喊他的名字来指挥他来帮助我们来干活. 

比如前面的\mintinline{ruby}{print "I'm Lucky. "}, 这个时候我们的金刚力士的名字叫做"print". 就像是友人帐一样, 当我们大喊它的名字的时候, (假如它是记录在帐的话), 它就能够跳出来, 然后接受我们的命令(也就是我们传入的参数), 最后就老老实实地去执行自己的任务. 

上面的都已经是见过面的结构形式了. 但是我们可能也会想要增加新的"朋友"到自己的友人帐上. 这个时候, 我们就会需要有这样的形式: 

\begin{quotation}
  \begin{minted}{ruby}
    def method_name (parameter)
      # ...
    end
  \end{minted}
\end{quotation}

没错, 这个的形式和我们之前见过的形式都不太一样. 所以我们就将这个形式称为一种特殊的形式. \footnote{这个时候我就有点想要介绍Lisp的语法了, 毕竟它只有一种形式, 这样的话学起来非常的漂亮. 但是问题就是, Lisp的思维太美妙了, 我认为目前我的理解不能够很好地表现这样的东西. 不过我最近在读了, 所以应该会把一些类似的东西合成进来. }

举个例子, 假如有这样的一个方法\footnote{其实也有很多人把这个东西叫做函数, 在这本书里面, 两种叫法我都会使用, 所以加入你一下子看到我说方法, 一下子看到我说函数的话, 请不要觉得奇怪. 我在之后会尽量规范些使用的. }定义: 

\begin{quotation}
  \begin{minted}{ruby}
    def puts_each_char(str)
      str.each_char do |c|
        puts c
      end
    end
    print_each_char("Lucky")
  \end{minted}
\end{quotation}

一个朴素的理解方法就是, 每当出现有调用的形式, 即\mintinline{ruby}{print_each_char(str)}的时候, 也就是上面的\\\mintinline{ruby}{print_each_char("Lucky")}, Ruby就会把这个在定义中的\mintinline{ruby}{str}记作\mintinline{ruby}{"Lucky"}, 然后执行在定义中的那一段代码. 

\begin{example}
  我们可以用这样的形式结构来为过程命名, 然后在之后进行调用. 这样的好处就是我们可以讲复杂的过程用一个简单的名字来代替. 这样我们就拥有能够将一个复杂过程化简成简单过程的组合的能力. 

  比如说, 我们想要一个能说废话的小精灵, 当我们喊出它的名字(这里我把它叫做\textbf{say})的时候, 就能够输出一些类似于"令人讨厌的棉线写问题"这样的虽然看起来挺符合语法, 但是却没什么意思的随机句子. \footnote{这个例子来自于\href{https://github.com/norvig/paip-lisp}{PAIP}一书. 顺带一提, 这本书我觉得也很有意思. 原书所用的是Common Lisp, 我这里给出了一个Ruby的实现. }
  
  \begin{quotation}
    \begin{minted}{ruby}
      # 一句废话由主谓宾构成
      def say
        return subject() + verb() + object()
      end
      
      # 主语就是形容词加上名词
      def subject
        return adj() + noun()
      end
      
      # 宾语也是形容词加上名词, 所以和主语一致
      def object
        return subject()
      end
      
      # 动词是...
      def verb()
        pattern = ["缠", "解", "是", "写", "讨厌", "觉得"]
        return pick(pattern)
      end
      
      # 形容词是...
      def adj
        pattern = ["细长的", "令人讨厌的"]
        return pick(pattern)
      end
      
      # 名词是...
      def noun
        pattern = ["棉线", "问题", "书", "论文稿", "梦想", "想法"]
        return pick(pattern)
      end
      
      # 从一个数组中随便选择一个
      def pick(arr)
        length = arr.length
        return arr[rand(length)]
      end
    \end{minted}
  \end{quotation}

  在上面的过程中, 我们实现了一个能够说出狗屁不通废话的小机器人啦. \footnote{作为一个例子, 我\mintinline{ruby}{say()}得到的结果是\mintinline{ruby}{"令人讨厌的问题是令人讨厌的想法"}, 竟然还算是有点意思. 毕竟这是因为词库选得好嘛. \\ 又, 据说在早期的人工智障Siri里面, 某些句子就是通过编写很好的词库来实现的. 这种生成语句的方法的缺点十分明显: 即前一句和后一句话可能是毫无关联的话语, 即上下文无关生成; 并且句子中的成分之间的关系也是十分脱节的, 比如我们可能会得到一些类似于"细长的问题写细长的问题"这样的东西. 不过哪怕是一个简单的例子, 其实我们也有可以玩着耍的地方. } 在某种程度上说, 我们通过构造方法和抽象的方式来实现了下图一样的一个简单的语言结构: 

  \begin{figure}[h]
    \centering
    \begin{tikzpicture}
      \tikzset{grow'=right,level distance=60pt}
      \tikzset{execute at begin node=\strut}
      \tikzset{every tree node/.style={anchor=base west}}
      \Tree [.一句话 [.主语 [[.形容词 ] [.名词 ]]] [.谓语 ] [.宾语 [[.形容词 ] [.名词 ]]]]
    \end{tikzpicture}
    \caption{注意, 我在这里的写的语法结构是错的, 这是写完之后才发现的. }
  \end{figure}
  
  没错, 我在画完上面的那个树状图后就发现了不对劲的地方, 因为我把语法结构给搞错了. \footnote{形容词应该归为定语的成分的, 不过实在是尴尬, 语文学的不太行. } 那么通常的想法应该是去修改函数之间的关系, 然后, 比方说, 加入一个补语的函数, 然后重新更改\textbf{say}函数的逻辑... 

  上面的逻辑体现了引入过程抽象(即函数)的好处: 我们只需要修改对应部分就能够达到控制整体的效果, 而在使用函数的时候, 只需要知道如何输入就会得到如何输出 -- 即一个\href{https://en.wikipedia.org/wiki/Black-box_testing}{黑箱方法}. 但是, 是不是总觉得这样仍然看不出来有什么特别便利的地方呢? 于是新的想法产生了, 如果我们能够构造这样的一个函数, 能够自动根据输入语法结构来生成结果的话, 在某种程度上来说是否就更加便捷了? 

  于是我们先做一些形式上的约定, 假如用一个哈希表来表示语法的转移规则, 每一个键对应着语法树上的一个节点, 用一个数组来表示节点的分支, 而用一个数组套数组的形式来表示从中任意选择一个值. 于是就可以构造出这样的一个树: \footnote{在\LaTeX 里面, 我使用的是\href{https://ctan.org/pkg/minted}{minted}包来输出代码的, 但是看来对中文字符的支持好像不太行? \\ 又, 因为尝试使用tikz包画出语法树而形态爆炸, 所以我决定先不放语法树了, 请留作自己的思考吧. (放心, 用手画很快的, 只是tikz包有点坑爹. 标记型语言真是狗啊. )}

  \begin{quotation}
    \begin{minted}{ruby}
      grammar = {
        :句子 => [:定语_, :主语, :谓语, :定语_, :宾语, :补语_],
        :主语 => [:名词], :定语 => [:形容词], :宾语 => [:名词],
        :定语_ => [["", :定语]], :补语_ => [["", :补语]], 
        :补语 => [:介词, :定语_, :主语], :谓语 => [:动词],
        :名词 => [["棉线", "问题", "书", "论文稿", "梦想", "想法"]], 
        :形容词 => [["细长的", "令人讨厌的"]], 
        :动词 => [["缠", "解", "是", "写", "讨厌", "觉得"]],
        :介词 => [["在", "于", "与", "和"]]
      }
    \end{minted}
  \end{quotation}
  
  那么我们构造这样的一个过程来处理给定的grammar: 

  \begin{quotation}
    \begin{minted}{ruby}
# 根据规则来输出句子
# 定义中的+res = :句子+表示变量res的默认值就是+:句子+
def generates(rules, res = :句子)
  out = ""
  rules[res].each do |item|
    if item.is_a? Array # 随机选择
      choice = pick(item)
      if choice.is_a? String
        out << choice
      elsif rules.include? choice
        out << generates(rules, choice)
      end
    elsif item.is_a? Symbol # 是节点
      out << generates(rules, item)
    end
  end
  return out
end
    \end{minted}
  \end{quotation}

  这个时候我们的程序实现中就只有一个函数\footnote{如果你试着运行的话\mintinline{ruby}{generates(grammar)}, 你就会得到类似于"想法缠想法和书", "令人讨厌的论文稿是细长的棉线"这样无厘头的废话. }, 并且和之前为描述过程构造函数的想法不同, 这个时候我们是通过为带有一定格式的数据(也就是我们用来表达\textbf{grammar}的语法结构的数据)构造一个脚手架 -- 你可以这样想象: 我们的程序就像是一个运行在有结构的数据上的一个机器. 

  \begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{image/chapter/1_language/operate_on_data.jpg}
    \caption{我们的机器运行在有结构的数据上}
  \end{figure}

  % 正是因为数据有一定的结构, 所以我们可以编写一定的程序来根据数据的结构来进行处理. 这个时候, 我们的过程的抽象更进了一步: 我们是把数据看作是描述过程的数据. 

  这个时候我们的思路是这样的: 用一种格式化的方式描述数据, 然后构造能够将数据转化为过程的函数. 这个时候, 可以说我们不仅仅是将原本的过程抽象为一个名字了, 而是将数据当作过程, 进行了一次抽象. 这样的好处就是我们将过程描述为了一种数据, 这样的数据能够进行交换, 传递, 处理等等操作. 而实际上, 我们制作的程序不过是一种将数据翻译成过程的程序而已. \footnote{我们会在之后继续介绍一些关于这样抽象的想法. }

  我们这样的抽象所带来的一种优势, 就像是我们重新定义了一种语言, 只要我们能够将过程描述为满足其语法或结构的数据, 便都能够将过程传递储存. 也就是说, 哪怕这段\textbf{generates}代码并不是用来生成上面的句子, 而是用来生成一篇狗屁不通议论文的话, 也能够通过类似的结构来生成文章. \footnote{这里只是给一个我高中想到的无聊的框架, 只是一个概念, 实际的实现肯定没有那么简单吧. 比如说: 段落 => 论点, 例子, 论点; 文章 => 下定义的段落, 讲缺点的段落, 讲适度利用的好处的段落, 还有啥我忘光了...} 或者是来一个可以随机编程的机器, 比如通过\mintinline{ruby}{a.b(c)}的结构来随机生成一段Ruby代码. (就作为一个思考游戏吧. 没准能够有点用处. )
\end{example}

\subsubsection*{类型和模块}
我们前面遇到的普遍类型都是有着\mintinline{ruby}{a.b(c)}的形式. 其中\textbf{a}被我们形式地称为对象, \textbf{b}被我们形式地称为对象的方法, \textbf{c}被我们形式地称为对象方法的参数. 

并且我们也知道, 对象有许多的种类, 比如我们前面介绍过的数组, 哈希, 字符串, 整数, 符号等等. 这些种类有着它们自己的名字. 并且假如我们也想要构造类似的种类的话, 我们可以如下形式地定义: 

\begin{quotation}
  \begin{minted}{ruby}
    class Name
      def method_name
        # ...
      end
      # ...
    end
  \end{minted}
\end{quotation}

比如说我们今天遇到了一个神奇动物师, 比如说他养了一堆不同的神奇动物在自己的帽子里. \footnote{其实我觉得在帽子里养神奇动物更有意思. 毕竟据说英国绅士都有一顶绅士帽. }因为他是专业养殖户(误), 所以对神奇动物的了解和分类是一流的. 比如说, 对于\textbf{LazyCat}, 它的叫声是咪咪呼呼; 对于\textbf{LostPigeon}, 它的叫声是咯咯咯咯; 而对于\textbf{DearDeer}和\textbf{TwoEarRabbit}尽管它们的叫声, 据这位资历丰富的动物学家所说, 还未被人类听过, 但是它们都属于\textbf{MagicAnimal}. 

\begin{figure}[h]
  \centering
  \includegraphics[width=0.25\textwidth]{image/chapter/1_language/class_of_animal.jpg}
  \caption{动物学家}
\end{figure}

于是我们就能够用上面的例子来形式地定义这些神奇的动物: 

\begin{quotation}
  \begin{minted}{ruby}
    class MagicAnimal
      def bark
      end
    end

    class LazyCat < MagicAnimal
      def bark
        puts "咪咪呼呼"
      end
    end
    
    class LostPigeon < MagicAnimal
      def bark
        puts "咯咯咯咯"
      end
    end

    class TwoEarRabbit < MagicAnimal
    end
    
    class DearDeer < MagicAnimal
    end
  \end{minted}
\end{quotation}

于是他坐下来和我们聊了聊他和自己的小猫\textbf{kitty}的发现过程, 在神奇的一个月夜, 坐电梯到楼下扔垃圾, 然后在雾蒙蒙的视野里, 忽然看见了一双黄色的眼睛, 闯过了灰暗的雨雾在墨绿色的垃圾桶上闪耀. 两个家伙面面相觑, 就像是被施了定身术一般, 时间停止了流动. 

嗯, 所以用Ruby的代码来描述就是: 

\begin{quotation}
  \begin{minted}{ruby}
    kitty = LazyCat.new
    kitty.bark # => 咪咪呼呼
    kitty.class # => LazyCat
    kitty.class.superclass # => MagicAnimal
  \end{minted}
\end{quotation}

这个时候我们就得到了一只LazyCat. 并且我们也能够知道它的从属关系. 并且就像是那位魔法动物学家坚信的那样, 所有的MagicAnimal都应该会bark, 只是不同种类的叫声不同. (虽然正如他所说, 还有一些种类的MagicAnimal的叫声他并没有听过)

除了像这样的\textbf{class...end}, Ruby中还有一种\textbf{module...end}形式的一组关键词. 后者在定义的形式上和前者别无二致, 所以我便不再介绍了. (但是在后面会详细介绍相关内容的\footnote{这个东西叫做Namespace, 如果想要提前了解的话, 可以去搜索相关的内容. })

% \subsection{简单的分解和组装的例子}
% \begin{quotation}
%   我的目的是想说明, 这一天空机器并不是一种天赐造物或者生命体, 它只不过是钟表一类的机械装置(而那些相信钟表有灵魂的人却将这一工作说成是其创造者的荣耀). 在很大程度上, 这里多种多样的运动都是由最简单的物质力量产生的, 就像钟表里所有活动都是由一个发条产生的一样. 
%   
%   约翰尼斯·开普勒(给Herwart von Hohenburg的信, 1605)
% \end{quotation}
% 
% 我们还是先来一些比较简单的东西来体现计算机编程的一些有趣的地方吧. 现在我会给出一个比较简单的程序, 然后利用我在前面讲到的方式来分析. 这个程序的功能就是从\href{https://xkcd.com}{xkcd的网页}上面下载几张照片. 
% 
% 那么首先我们先来一个脑筋急转弯: 把大象放进冰箱需要几步? 
% 
% 打开冰箱, 找到里面的长颈鹿, 把长颈鹿拿出来, 把长颈鹿放到一个别的地方, 把大象放进冰箱, 关上冰箱门. 
% 
% 我稍微搜索了一下, 发现原来这个古早脑筋急转弯有那么多的神奇来历. 对于小时候的我, 我从未想过会有类似于苏联笑话一样的东西, 或者是什么类似于外行指导内行的批判. \footnote{啊, 怎么说呢. 还是将我的这个例子就当作是一种笑话吧. } 不过现在我在想, 其实这些不过是一个概念, 对于小时候的我, 因为不考虑其内部的任何实现, 任何工程性的难题. 因为当时我觉得这就像是概念的组织, 一种类似于形式的东西. 不论是把大象还是恐龙放进冰箱, 对于但是的我来说没有任何的困扰. 其实我觉得没什么问题, 从网页上下载图片和把大象装进冰箱这两种事情实际上都是一些抽象的事情. 为了做到这些事情, 我们需要将抽象的操作细化分成一系列的具体的事情. \footnote{但是我们不需要一口气分解到底层, 我们要做的是一点点的分解, 就像是剥洋葱一样, 层层的抽象层让我们在深入理解的时候会更加的舒适. }
% 
% 同样的, 要从网页上下载图片. 想想看平时我们是怎么使用鼠标和图形界面操作系统的时候是怎么做的: 打开了游览器, (输入网址)进入网站, 然后找到网页上的图片链接(xkcd的网页上为了方便"盗图", 直接给了我们一个图片的链接), 然后用下载工具下载这个链接的图片: 
% 
% \begin{figure}[h]
%   \centering
%   \includegraphics[width=0.75\textwidth]{image/chapter/1_language/xkcd.png}
%   \caption{xkcd的网页\footnote{2022/4/4的快照}, 注意下方有图片的地址哦}
% \end{figure}
% 
% 但是你会发现, 自己假如想要保存很多照片的话, 或者不是很想要自己来干活的话, 这个时候你就会想要说: 啊, 我想要能够自动化操作这些事情, 让这些呆头事情交给电脑来干活吧. 
% 
% \begin{quotation}
%   \begin{minted}{ruby}
%     # 导入一个能够帮助我们使用http协议访问网页的库
%     require "net/http"
% 
%     # 储存我们要访问的网页的地址
%     url = URI("https://xkcd.com/224/")
%     # 访问网页
%     response = Net::HTTP.get(url)
% 
%     # 在网页中按照图片链接的形式来找到链接的图片名字, 
%     # 并将其转换为字符串储存在image_name里面
%     image_name = response.match(/\w+\.jpg/).to_s
% 
%     # 打开一个图片名字的文件, 并写入文件
%     File.open(image_name, "w") do |f|
%       image_url = URI("https://imgs.xkcd.com/comics/#{image_name}")
%       f.write(Net::HTTP.get(image_url))
%     end
%   \end{minted}
% \end{quotation}
% 
% 让我们来一点点地解释上面的语句的意义吧: \footnote{注: 就像是页底注一样, 在Ruby代码里面也有注释, 凡是用\textbf{\#}开头的, 后面跟着的东西都是注释. 也就是不会被Ruby当作是代码来处理. }
% 
% 首先是第一段: \mintinline{ruby}{require "net/http"}这个是告诉我们要使用一个叫做\textbf{http}的在\textbf{net}这个大范围下面的一个库(也可以叫做gem\footnote{这个的原本的意思就是宝石, 是不是非常的形象? 因为有这些像宝石一样好用的库, 才让我们的软件开发变得非常的方便和快捷. }). 什么是库呢? 库实际上就是一种"站在巨人的肩膀上"的一种东西, 前人帮我们建立好了完善的库, 然后我们只需要按照规则和约定形式地调用就好了. 实际上是一种抽象的概念: 我们不必在意冰箱的内部构造, 不需要思考热力学的热机, 也不需要担心转轴和密封性. 只需要知道, 冰箱有一个门, 可以打开和关上; 冰箱里面可以放东西. 仅此而已, 就可以利用冰箱这样的神奇的东西. \footnote{但是这样的话我们就会失去对底层的了解, 假如我们想要造一台利用冰箱原理的冰库, 或者需要设计一个使用冰箱的制冷机技术的空调, 这时候我们就有必要了解如何hack掉那个压缩机才能进一步深入了. }
% 
% 我们所用的这个\textbf{net/http}库的作用就是可以方便地帮助我们通过HTTP协议来链接网页. 
% 
% 然后是第二段访问网页的操作: 首先是告诉Ruby, 要用一个变量\textbf{url}, 就像是名字(或者是外号)一样, 记下网页的地址并方便以后的使用. 然后告诉Ruby, 我们要用一个在\textbf{Net}里面的\textbf{HTTP}里面的方法\textbf{get}方法(method)来取得网页. 
% 
% 接下去那一段就是在网页的返回的内容里面找出图片, 我们使用了一种叫做正则表达式(Regexp)的方式来匹配有一定模式的文本, 具体的组织方式我们将会在之后介绍, 现在我简单地介绍一下: 上面的\mintinline{ruby}{/\w+\.jpg/}的功能就是用来匹配\textbf{文字.jpg}这样的东西. \footnote{不过假如你想要卷的话, 不妨了解一下: \href{https://ruby-doc.org/core-3.1.1/Regexp.html}{Regexp}, 学会看文档也是一种很有必要的技能哦. 虽然现在可以不了解, 但是以后还是建议掌握. }也就是我们的图片的名称. 
% 
% 最后是将这个图片名称变成链接, 然后保存在文件里面. 这里我们会看到一个使用\textbf{File}中的\textbf{open}方法来用写("w", 也就是write属性)打开, 简单记为\textbf{f}来方便我们在代码块里面使用. 最后往里面写\textbf{write}图片链接里面的内容呢. \footnote{我觉得还是很有必要介绍一下如何运行代码吧, 虽然我会在附录里面更详细地介绍. 简单来说, 就是将代码保存到文件(比如叫做\textbf{download\_pic.rb})里面, 然后在命令行里面输入命令 \textbf{ ruby download\_pic.rb } 最后就能够运行啦. 记得查看运行的目录里面是否有保存的图片文件出现哦. }
% 
% 上面的过程我们其实只实现了一个网页的下载, 那么我们接下来试试看下载更多的网页吧: 
% 
% \begin{quotation}
%   \begin{minted}{ruby}
%     # 导入一个能够帮助我们使用http协议访问网页的库
%     require "net/http"
% 
%     # 储存我们要访问的新的网页的地址
%     url = URI("https://xkcd.com/54/")
%     # 下面同理... 
%     response = Net::HTTP.get(url)
%     image_name = response.match(/\w+\.jpg/).to_s
% 
%     File.open(image_name, "w") do |f|
%       image_url = URI("https://imgs.xkcd.com/comics/#{image_name}")
%       f.write(Net::HTTP.get(image_url))
%     end
%   \end{minted}
% \end{quotation}
% 
% 我们会发现, 诶, 上面的代码不是和之前的代码几乎一模一样吗? 不过就是修改了一下新的\textbf{url}罢了. 假如有一种东西, 能够只需修改\textbf{url}, 就能够运行类似的过程就好了. 所以我们就要进入到一个抽象的概念中了: 
% 
% \begin{quotation}
%   \begin{minted}{ruby}
%     require "net/http"
% 
%     # 定义了一个方法(函数)
%     # 下载xkcd网站中对应链接的图片漫画
%     def download_image(link)
%       url = URI(link)
%       response = Net::HTTP.get(url)
%       image_name = response.match(/\w+\.jpg/).to_s
% 
%       File.open(image_name, "w") do |f|
%         image_url = URI("https://imgs.xkcd.com/comics/#{image_name}")
%         f.write(Net::HTTP.get(image_url))
%       end
%     end
% 
%     download_image("https://xkcd.com/54/")
%     download_image("https://xkcd.com/53/")
%     download_image("https://xkcd.com/52/")
%   \end{minted}
% \end{quotation}
% 
% 
% 于是, 我们相当于只需要一句话就能够调用原来的长长的一串命令. 在形式上看, 我们就像是告诉Ruby, 记下一个叫做\textbf{download\_image}的函数名字. 然后每次Ruby看到这个名字的时候, 就都会去"回忆"一下之前定义的函数的内容. 然后我们传递给函数的参数将会按照顺序告诉函数的代码块里面. \footnote{之后会详细介绍参数的使用方法的, 现在只需要知道我们的函数的参数都是按顺序传递的就好了. 唯一稍微需要注意的就是, 我们之前介绍的代码块(block)是在最后传递给函数的. }
% 
% 这个时候我们只需要使用"黑箱方法"就能够调用原本复杂的方法, 即不需要知道其中具体的实现和细节, 只需要知道宏观的外部的调用方法, 就能够使用该程序和函数了, 这就是黑箱方法. 这里就体现了一种抽象的概念: 我们将一个复杂的过程抽象成一个简单的结构. 就可以非常轻松地调用了. 

\section{Get Your hands dirty}
\begin{quotation}
  我的目的是想说明, 这一天空机器并不是一种天赐造物或者生命体, 它只不过是钟表一类的机械装置(而那些相信钟表有灵魂的人却将这一工作说成是其创造者的荣耀). 在很大程度上, 这里多种多样的运动都是由最简单的物质力量产生的, 就像钟表里所有活动都是由一个发条产生的一样. 
  
  约翰尼斯·开普勒(给Herwart von Hohenburg的信, 1605)
\end{quotation}

上面的故事里面, 我们只是在做类似于思想训练的东西, 没有接触很多实际的操作. 这怎么可以呢. 只是想想, 却不实际操作, 总觉得有一种画饼的意味. 所以接下来我们来实际地接触一些实际的东西. 

(又: 我现在觉得实际的东西还是在迟一点点来吧, 下面的东西请务必操作\footnote{关于操作的问题, 建议使用irb(Interactive Ruby)来操作. 关于这个, 可以看看我的这个\href{https://li-yiyang.github.io/ruby/why's_(poignant)_guide_to_ruby/why's-poignant-guide/}{翻译}. 之后会在附录中加入一些关于这个irb的介绍的. }试试看. )

\subsection{过程视为数据}
\begin{quotation}
  舍利子, 色不异空, 空不异色, 色即是空, 空即是色, 受想行识, 亦复如是. 舍利子, 是诸法空相, 不生不灭, 不垢不净, 不增不减. 

  \emph{《般若波罗蜜多心经》}\footnote{在\href{https://zh.wikipedia.org/wiki/般若波羅蜜多心經}{维基百科}上对这句话的解释是: 一切的"形态", "影像", "物质"都是"无常", "非固定", "不恒久"的. \\说一个没什么关系的事情. 我记得很久之前我读过一篇相关的文章, 写的很不错. 但是现在在网上怎么找也找不到了. 真是麻烦. \\(下面的理解不过是我个人的主观臆断, 只是为了方便引入我下面介绍的内容所以介绍的. 请专业佛学院的读者放过我. ) 既然空(无常与变化)和色(物质与形态)并非是对立的关系, 那么便不必将二者所对立起来. 与其坚持"说一切有", 或者是为了追求"空"而追求. 所以与其追求一极, 不如观察其中的统一性而辩证地去认识. }
\end{quotation}

我们的在前面构造的说狗屁不通废话的小机器人是将数据看作一种组织生成语言的过程. 我们构造了 \\\mintinline{ruby}{grammar} 这个数据表, 描述的是如何生成一句话的过程, 即通过主谓宾这样的结构来生成句子的一个过程. 

比如说我们写下了一段代码, 并将其保存在文件里面, 然后运行这段代码\footnote{具体的方法就是: 用文本编辑器编辑一段代码, 常见的文件名后缀是\textbf{.rb}. 然后在终端中执行命令\mintinline{shell}{ruby filename.rb}就能够执行代码了. 或者也可以通过irb来运行代码. }, 这个时候我们是把过程视为数据储存在计算机中. 在Ruby中(以及其他的很多的一些编程语言中)都有一种\textbf{eval}的函数, 能够将储存在数据中的过程视为代码并执行: 

(在irb中运行代码)

\begin{quotation}
  \begin{minted}{ruby}
    3.0.0 :001 > data = "puts 'Hello'"
      => "puts 'Hello'" 
    3.0.0 :002 > eval(data)
    Hello
      => nil 
    3.0.0 :003 > puts 'Hello'
    Hello
      => nil 
  \end{minted}
\end{quotation}

可以发现, 作为字符串储存的一段代码数据, 现在就能够被作为代码来执行. 在eval函数的背后, 其实有一个和我们前面构造的generates函数相类似的构造, 能够处理代码. 将保存在文本文件里面的Ruby代码变成计算机能够理解的过程数据. 

但是这个时候我们不妨这样想: 既然我们可以用数据来描述过程. \footnote{其实我们的编程过程也就只是一种用数据来描述过程的想法. 就像是很早之前的纸带计算机, 据说是将程序用打孔器在纸带上按照规律来打孔, 然后传入计算机, 作为程序来运行. } 那为什么不能够把过程看作是数据, 来对像数据一样的过程进行处理呢? 

于是, 基于这样的想法就构造了一种Lambda表达式, 即一种能够生成过程的表达式. 

\begin{quotation}
  \begin{minted}{ruby}
    func = -> (param) {
      # ...
    }
    func.call(param)
  \end{minted}
\end{quotation}

上面就是形式的Lambda表达式的定义方法. 在形式上, 我们就像是构造了一把宝剑. 

\begin{figure}[h]
  \centering
  \includegraphics[width=0.25\textwidth]{image/chapter/1_language/lambda_sword.jpg}
  \caption{看我的大师剑! }
\end{figure}

矮人族的工匠们都知道如何打造一把优秀的剑: 握住剑柄(也就是我们的\textbf{->})部分, 郑重地在其上镶上能够赋予其魔力的力量宝石(也就是我们传入的参数表), 最后和精心打造的剑身(也就是我们的\textbf{\{\}}的部分). 于是一把威力巨大的宝剑就诞生了. \footnote{lambda演算在1937年被Alan Turing证明和图灵机是等价的计算模型, 也就是一种满足图灵完备的计算模型. 并且lambda演算形成了所有函数式编程的基础. \\"比起指令式编程, 函数式编程更加强调程序执行的结果而非执行的过程, 倡导利用若干简单的执行单元让计算结果不断渐进, 逐层推导复杂的运算, 而不是设计一个复杂的执行过程. "(\emph{摘自\href{https://zh.wikipedia.org/zh-cn/函数式编程}{维基百科}})\\ 不过在实用的工业领域, Lambda表达式更多地会被叫做匿名函数. 因为它们就像是没有名字的函数, 可以不必用\textbf{def}这样的语句来为这个过程来定义名字就可以直接使用, 比如\mintinline{ruby}{-> { puts "Hello" }.call # => Hello}. 并且还能够将其保存到变量里面, 在日后调用. } 

自古以来, 人们都认为矮人们是最伟大的工匠, 并且是固执重视荣誉, 直至死战到最后一兵一卒的英勇战士. \footnote{来自《魔戒》中矮人的形象, 注: 根据维基百科, 矮人们贪恋金银财宝, 于是导致了因为诱惑而杀害了精灵王而与精灵结怨的悲剧. 不过我们都请求他们为我们打造了如此强力的工具了, 还是只介绍他们的优点, 而将这略有遗憾缺点留在脚注的空间里吧. } 他们将充满魔力的宝石附到剑上, 念动咒语, 宝剑就开始了魔法的转化, 对于其中的转化, 我们还是不必多说了吧, (因为那可是矮人们的技术呢): 

\begin{quotation}
  \begin{minted}{ruby}
    sword = -> (spell) { puts "#{spell.upcase} Sword!" }
    spell = "fire"
    sword.call spell # => FIRE Sword!
  \end{minted}
\end{quotation}

灵巧的矮人们打造出了一把把宝剑, 除了挥舞宝剑在战场上厮杀以外, 我们还能够看到史诗中的英雄们如何从矮人那得到传说中的宝剑, 最后凭借着这把宝剑取得神圣的胜利. 这个时候, 胜利不再是一个这样那样的过程, 而是被扼在工匠的手中, 由一锤又一锤的敲击下将无数命运塑造成一个实物传递到了英雄的手中. 这个时候, 我们不再是将Lambda表达式仅仅看作是一种描述过程的东西, 而是将其看作是一种将过程数据化的东西. \footnote{感觉有点像是代数里面的映射到函数空间的映射. 不过这种我自己都搞不清楚的东西, 还是不要作为例子来介绍了吧. } 现在我们能够将过程当作数据来传递了. 

举个例子, 我们之前例子里的$\sum_{i=0}^n a_i$的求和表达式. 如果用\textbf{def}的方式来定义, 我们可能就要对每一个不同的$a_i$表达式来定义不同的求和函数了: 

\begin{quotation}
  \begin{minted}{ruby}
    def sum_i(start, stop)
      sum = 0
      (start..stop).each do |i|
        sum += i
      end
      return sum
    end

    def sum_square_i(start, stop)
      sum = 0
      (start..stop).each do |i|
        sum += i ** 2
      end
      return sum
    end

    # ...
  \end{minted}
\end{quotation}

尽管上面的求和很方便, 但是在构造的过程中, 出现了许多重复的代码. 毕竟编程在很多时候是为了帮助人们减少重复单调的操作, 但是倘若编程本身就成为了单调重复的事情, 那不就变成了舍本逐末的事情了吗? 所以我们可以通过这样的方式来简化\textbf{sum}的过程: 

\begin{quotation}
  \begin{minted}{ruby}
    def sum(start, stop, func)
      sum = 0
      (start..stop).each do |i|
        sum += func.call(i)
      end
      return sum
    end

    # sum of i
    sum(1, 5, -> (i) { i }) # => 15
    # sum of square i
    sum(1, 5, -> (i) { i ** 2 }) # => 55
  \end{minted}
\end{quotation}

上面的代码, 我们通过把过程用Lambda表达式\mintinline{ruby}{-> (i) { i }} 和 \mintinline{ruby}{-> (i) { i ** 2 }}来表示成数据, 然后传递给\mintinline{ruby}{sum}函数, 这样就简化了复杂过程的构造了(因为我们共用了\textbf{sum}的这段构造过程. ). 

这就好像是我们的\mintinline{ruby}{sum}勇士接到了国王给他的命令和御赐的尚方宝剑. 这样的命令告诉\mintinline{ruby}{sum}勇士, 他要从\mintinline{ruby}{start}开始征讨, 一致将皇帝的疆土拓展到\mintinline{ruby}{stop}处为止. 而面对每一个企图兴风作浪的敌人, 他就要拿起皇帝赐给他的宝剑砍向他们, 将他们的头颅挂在腰间, 作为战利品上交给他神圣的皇帝. 

% \begin{example}
%   不仅如此, 我们甚至还能够使用Lambda表达式来表示更多的东西. \footnote{下面的例子来自于《计算的本质：深入剖析程序和计算机》一书. 叫做Church numeral. 是\href{http://dx.doi.org/10.2307/2371045}{Lambda演算}的发明者Alonzo Church提出来的一种表示数的方式. \\其实在数学里面也有类似的定义, 比如说在数学分析的书里面就有介绍用集合的方式来表现包含零的自然数: 比如用$\varnothing$来表示$0$, $\{\varnothing, \{\varnothing\}\}$表示$1$, 以此类推就能够表示任何的数了. }
% 
%   那么如果想要构造一堆数, 只要构造一个零, 一个一, 然后构造加法就好啦. 
% 
%   \begin{quotation}
%     \begin{minted}{ruby}
%       zero = -> f { -> x {    x    }}
%       one  = -> f { -> x {  f[x]   }}
%       two  = -> f { -> x { f[f[x]] }}
% 
%       def to_i(lambda_number)
%         lambda_number[-> n { n + 1 }][0]
%       end
% 
%       def add(a, b)
%         
%       end
%     \end{minted}
%   \end{quotation}
% \end{example}

不过其实往函数里面传入作为数据的过程其实我们早就已经见过了. 在Ruby里面, 我们实际上已经见过类似的过程了. 回想一下, 这不就是我们的代码块block吗? 比如说, 假如我们有这样的一个\textbf{sum}函数, 能够像这样来调用: \mintinline{ruby}{sum(start, end) { |i| i ** 2 }}之类的. 我们可以像这样来定义这个sum函数: 

\begin{quotation}
  \begin{minted}{ruby}
    def sum(start, stop, &block)
      sum = 0
      (start..stop).each do |i|
        sum += yield i
      end
      return sum
    end

    # sum of i
    sum(1, 5) { |i| i }
    # sum of i ** 2
    sum(1, 5) { |i| i ** 2 }
  \end{minted}
\end{quotation}

(这部分还需要重新写... )

在上面结构中, 注意到在定义函数\textbf{def}的时候, 我们引入了一个特殊的符号来标记我们的输入参数: \textbf{\&}, 这个符号的意思是为了告诉计算机, 这个函数可以接受一个代码块的输入, 而在函数定义的内部, 我们又会发现一个特别的字眼: \textbf{yield}, 这个字眼的作用就是将参数抛给代码块(我们的代码块上面不就是有一个形式上的参数管道吗? 我们的参数就像是从那里被传递进去的. )而代码块执行完毕后的值则会被这个字眼作为返回值传递到函数体的内部. 

不妨这样想, 我们构造的函数是这样的一个机器, 我们在使用这台机器的时候, 设定好参数, 然后将其用一个管道和外部的一个装置来连接在一起, 机器运作的时候, 内部会将一些数据传给装置, 而装置又会将其计算结果传给内部. 

\begin{example}
  在Ruby中, 还有很多这样类似的代码块的操作, 比如说我们前面使用的\textbf{each}等等. \footnote{我接下来的例子部分参考了Arnau Sanchez的文章, 这里是\href{https://github.com/JuanitoFatas/Ruby-Functional-Programming}{翻译}}
\end{example}

\subsection{用你的名字呼唤我}
\begin{quotation}
  O Romeo, Romeo, wherefore art thou Romeo?

  Deny thy father and refuse thy name.

  Or if thou wilt not, be but sworn my love

  And I'll no longer be a Capulet.

  `Tis but thy name that is my enemy:

  Thou art thyself, though not a Montague.

  What's Montague? It is nor hand nor foot

  Nor arm nor face nor any other part

  Belonging to a man. O be some other name.

  What's in a name? That which we call a rose

  By any other name would smell as sweet;

  So Romeo would, were he not Romeo call'd,

  Retain that dear perfection which he owes

  Without that title. Romeo, doff thy name,

  And for that name, which is no part of thee,

  Take all myself.

  \emph{from Romeo and Juliet, spoken by Juliet}
\end{quotation}

但是我不觉得名字不是很重要, 每一个优秀的巫师都知道真名\footnote{乐, 其实这个的真名更像是地址. 在我们熟悉的递上苹果的蛇的后裔之一 -- Python 中, 变量储存的就是值的地址的引用. }的重要性. 罗密欧抛弃了他的"名字", 但是他的自身并不会被因此抛弃. \footnote{这个我们可以用Python的变量来看看, \mintinline{python}{name = "Romeo"; new_name = name; id(name) == id(new_name) # => True}, 这个时候我们就会看见, 哪怕变量的名字不同, 只要它们指向的东西是一样的, 那么它们的identify(id)就都是一样的. 呃, 这个有点没意思, 因为Python的变量还是和C的指针有点区别, 这里看不懂没关系, 就跳过吧. } 倘若连自身的值(ego)都给扔了, 那么等待他的就只有被GC(垃圾回收机制)给消除的命运了. 

乐, 还是不要在意这些东西了, 让我们给他一个新的名字吧. 

\begin{quotation}
  \begin{minted}{ruby}
    name = "Romeo"
    price_of_the_sword = 1_000_000
    the_name_of_my_kitty = "Lucky"
  \end{minted}
\end{quotation}

上面就是一串的命名的过程. 我们通过形式化的一个\textbf{名字 = 值}的一个表达式来告诉Ruby, 我们要给这些值起一个名字, 其中值就是等号右边的内容, 名字就是等号左边的东西. 这样的表达式我们叫做赋值表达式. 

在地海传奇里面, "当知晓了某物/人之真名时, 便能成为其主人. "; 我们没必要使用那么大的杀器, 我只想在呼唤kitty的时候它能够回应一下. \footnote{但是我并没有小猫, 虽然我喜欢他们. } 那么在我们Ruby里面, 每一次我们喊出变量的名字的时候, Ruby就会帮我们找到那个变量名字对应的值, 然后拎起kitty的后颈, 把它轻轻地提到我们的面前. 

\begin{quotation}
  \begin{minted}{ruby}
    print "Where are you? ", the_name_of_my_kitty, " Come here! \n"
    print "Oh, yes! Here you are, my ", the_name_of_my_kitty
    # =>
    # Where are you? Lucky Come here!
    # Oh, yes! Here you are, my Lucky
  \end{minted}
\end{quotation}

(在上面的代码里面, 我们用\#号来表示注释, 所有在\#后面的东西都不会被Ruby看到, 所以我们用它来做一些小笔记. 就像不能被老师看到的小抄一样. )

并且就像我们给东西取名字的时候, 要有一定的规则, 不能随便乱起名字, Ruby里面, 给变量取名字也是一种小有学问的东西呢. 比如说, 我们不能够把名字取得让人混淆: \mintinline{ruby}{2333_is_not_a_variable}, \\\mintinline{ruby}{"name"_is_also_not_a_variable}, \mintinline{ruby}{:p_not_variable_name}, 这样的名字会让Ruby在阅读的过程中内心发出一堆的怀疑. 因为在Ruby看来, 这样的名字更像是数字, 字符串, 符号而不是变量名字, 但是后面跟着的东西有不像是数字, 字符串, 符号之类的东西, 这可真是让人头大. 所以Ruby就会非常生气地说我不干啦, 你好像出错了! \footnote{这个时候会报错: \textbf{SyntaxError}, (以\textbf{2333\_is\_not\_a\_variable}为例, 其他的你可以试试看)如果我们来尝试阅读一下报错的信息的话, 就会发现Ruby看到开头的数字就会认为是数字, 而看到紧跟的奇怪东西, 就会感到困惑, 最后爆出错误: \\ SyntaxError ((irb):*: trailing `\_' in number)\\(irb):*: syntax error, unexpected local variable or method, expecting end-of-input} 所以我们起名字的时候, 还是老老实实地取一个不是那么古灵精怪的名字吧. 比如说\mintinline{ruby}{a_good_name}, \mintinline{ruby}{the_name}, 之类的名字吧. \footnote{虽然数字之类的也是可以用在变量名字里面的, 比如\mintinline{ruby}{var_233}之类的, 但是怎么说呢, 看到这种带数字的名字, 我常常会感到十分的头疼. \mintinline{ruby}{v1, v2, v3}这样的东西写起来和看起来都像是在糊弄, 所以我不在正文里面介绍, 也不希望你学习, 因为这样的代码真的很难看. }

不知道你有没有发现, 很多专有名词名词在英文里面都是用大写字母开头的, 比如\textbf{China}, \textbf{English}, \textbf{German}之类的. 没错, 在Ruby里面, 我们也用大写开头的"变量"名字来表示一种"专有"的特色. 就像"一个中国"是不可动摇的原则一样, 用大写开头的"变量"名字也就像是在捍卫自己不可更改的坚定立场. 所以我们叫这样的量为常量. 不过Ruby也不是那种死脑筋, 假如你想要修改一个常量, 也不是不行. 因为这个是科学, 科学允许质疑, 否则你得到的只有教条. \footnote{比如说关于电子的荷质比的测量. 密立根油滴实验做的事情就比较坑爹了. 不仅卖了自己的学生, 还做了筛选数据的操作(让数据变得符合他的喜好). 导致了因为自己的诺贝尔奖, 把这个重要的科学常数的精确值的测量推迟了许久. 但是科学厉害之处就在于它是可以质疑, 不断修改精进的. } 只是Ruby会给你一个提示: "warning: already initialized constant", "(irb):line: warning: previous definition of Constant\_Name was here". 不过你还是最后能够修改常数的值啦. 

\begin{figure}[h]
  \centering
  \includegraphics[width=0.75\textwidth]{image/chapter/1_language/constant.png}
  \caption{常量也是可以改的}
\end{figure}

于是, 当我们想要把一个值保存起来, 然后以后再调用的话, 就可以利用赋值语句来实现我们的目的了. 在这个过程中, Ruby会将这些名字保存在自己的一个小册子里面, 然后每次见到一个看起来像是名字的时候, 就会去这个小册子里面翻找 -- 对了, 为什么不先看看这个神奇的小册子呢? 

(在irb中: )

\begin{quotation}
  \begin{minted}{ruby}
    local_varibles
    # => [:the_name_of_my_kitty, :price_of_the_sword, :name, :_, :version, :str]
  \end{minted}
\end{quotation}

可以看到, 在\textbf{local\_varibles}这个名字\footnote{其实是一个方法的名字}里面, 储存了我们的变量的名字. \footnote{这里是用Symbol类型来记录的. 又, 这里是一个无关紧要的小注释, 为什么要用Symbol而不是String呢? 这是因为相比容易可以发生变化的String, Symbol不太容易发生变化, 并且在比较和调用的时候比较快. 也就是说, 当你想要标记但是又不是很想打印的时候, 使用Symbol就是一个比较好的选择. } 但是假如我们访问了一个不存在于这个小册子里面的变量的时候, 就好像有人突然在你面前提到了一个你从来没有听过的名字, 这个时候, Ruby就会正直地提示你: 

\begin{quotation}
  \begin{minted}{ruby}
    an_undefined_name
    # => 
    # Traceback (most recent call last):
    #     4: from irb:*:in `<main>'
    #     3: from irb:*:in `load'
    #     2: from irb:*:in `<top (required)>'
    #     1: from (irb):*:in `<main>'
    # NameError (undefined local variable or method `an_undefined_name' 
    # for main:Object)
    an_undefined_name = "Hey, Ruby, this variable is such a thing. "
    an_undefined_name
    # => "Hey, Ruby, this variable is such a thing. "
    local_variables
    # => [:an_undefined_name, :x, :the_name_of_my_kitty, 
    # :price_of_the_sword, :name, :_, :version, :str]
  \end{minted}
\end{quotation}

可以看到, 这里Ruby在最后告诉你出现了一个\textbf{NameError}, 也就是对你的这个名字, Ruby会说, 嗯, 这个名字好像我没有见过. 当我们在Ruby里面定义了这个名字之后, 再次调用这个名字的时候, Ruby就知道了该拿什么了. 

众所周知, 情人眼里出西施. 罗密欧的眼里的"西施"是朱丽叶, 但是在其他人眼中的"西施"可就不一定是朱丽叶啦. 这就像是"一千个人眼中有一千个哈姆雷特"一样, 在不同的区域里面的变量可能会有不同的意义. 

在Ruby里面, 我们就有类似的"区域"的概念. 比如说我们在前面遇到过的代码块结构(\textbf{do...end}), 或者是我们见到过的定义方法的结构(\textbf{def name ... end})\footnote{以及在之后我们会遇到的Module, Class等的东西}等等. 在这里, 我只会简单地介绍一下这个"区域"的概念, 至于更加复杂的问题, 恕我先搁置一边啦. 

不知道你有没有玩过显微镜(其实望远镜也是一样的, 只是我没有玩过望远镜), 当我们选择了一个镜头看到了一堆 -- 比方说洋葱表皮细胞吧 -- 时, 你可能会感慨, 哇哦, 好厉害的细胞, 好漂亮的玩意儿! 然后, 为了更好地看清楚这些细胞, 你换上了一个更大放大倍数的物镜(嗯, 轻轻地旋转你的转换器, 不要让镜头压到你的载玻片), 这个时候, 你的视野聚焦在了一个更加精细的区域, 原来的密密麻麻的细胞们全部都从镜头的中心离开了, 只留下一个主角. 

Ruby中的"区域"就像是这样的东西. 这也就是为什么它的正式名字叫做\textbf{Scope}(显微镜的英文名字叫做mircoscope). 那么我们现在来一点点例子吧: 

(在一个新的irb进程里面: )

\begin{quotation}
  \begin{minted}{ruby}
    a_variable = "This is a variable"
    another_variable = "Oh, This is an other variable"
    def test_method
      a_variable_inside_method = "This variable is inside method"
      another_indside_variable = "Inside variable are not available outside"
      print local_variables
    end
    test_method
    # => [:a_variable_inside_method, :another_indside_variable]
    local_variables
    # => [:another_variable, :a_variable, :_, :version, :str]
  \end{minted}
\end{quotation}

上面我们就会发现, 在方法\textbf{test\_method}中的变量不是在外面的变量, 在外面的变量也不能够在方法中调用, 就好像是我们将显微镜的镜头对准了一个新的区域, 观察完后回到了原来的过程中. 于是在观察这个新的区域中时, 我们没法知道原来的区域里面有什么, 回到了原来的区域中后, 我们也不知道新的区域里面有啥. 这个时候, 我们就叫这样可以分别储存变量的区域叫做命名空间(NameSpace), 因为在里面我们可以自行命名东西而不用顾及其他命名空间. 

再来一些例子: 

\begin{quotation}
  \begin{minted}{ruby}
    x = 2333
    def print_x
      print x
    end
    print_x
    # => 
    # Traceback (most recent call last):
    #     5: from irb:*:in `<main>'
    #     4: from irb:*:in `load'
    #     3: from irb:*:in `<top (required)>'
    #     2: from (irb):*:in `<main>'
    #     1: from (irb):*:in `print_x'
    # NameError (undefined local variable or method `x' for main:Object)
  \end{minted}
\end{quotation}

上面的例子体现了不同的命名空间的名字是不通用的, 其实这个原因是因为在\textbf{print\_x}方法中的local\_variables里面, 没有x的名字. (僕わ知らない、君の名前, 乐)

(呃, 上面那一部分写的不是很好, 所以之后再想办法优化, 现在不想写了. )

但是这个时候就出现了一个问题, 假如一个意气风发的家伙狂妄自大地高喊, 啊, 我的话语是真理, 所有的人眼中的真理都该是我所说的话语, 我即是自由与民主... 那么这个人一定也会很反感"一千个人眼中有一千个哈姆雷特"的说法. 但是这个家伙太精明了, 他用金钱武装起自己的话语, 在全球分发传播自己的话术, 遇到阻碍就用金钱在前方开道, 于是他的话术就传播到了各个角落, 成为了"真理". 不过Ruby没有这么黑暗和腐败, 只是作为一种戏谑, 我们定义了一种类型的变量, 它们在命名的时候用美元符号(也就是金钱)开头, 然后不论是在那个角落, 这样的变量都是一样的. 

举个例子: 

\begin{quotation}
  \begin{minted}{ruby}
    $what_mr_k_said = "I'll make world great again! "
    $what_mr_k_did = "I just made the world worse first"
    def people_in_area_A
      print "This is what Mr.K said: ", $what_mr_k_said, "\n"
      print "This is what Mr.K did: ", $what_mr_k_did, "\n"
    end
    def people_in_area_B
      print "据说K先生说: ", $what_mr_k_said, "\n"
      print "他做了: ", $what_mr_k_did, "\n"
    end

    people_in_area_A
    # => This is what Mr.K said: I'll make world great again! 
    #    This is what Mr.K did: I just made the world worse first
    people_in_area_B
    # => 据说K先生说: I'll make world great again! 
    #    他做了: I just made the world worse first
  \end{minted}
\end{quotation}

果然, 用金钱开道的话, 所有的区域的人都知道这位意气风发的先生所说的东西了. 

欸, 我们还是抛开这种低俗的打趣笑话吧, 我认为这样的东西没有什么意思. 除了让人哈哈大笑之外, 完全没有任何的营养. 还是回到竹林或者书斋之中, 培养一颗宁静的心吧. 

\begin{quotation}
  人皆有不忍人之心. 先王有不忍人之心, 斯有不忍人之政矣; 以不忍人之心, 行不忍人之政, 治天下可运之掌上. 

  \emph{《孟子·公孙丑上》}
\end{quotation}

假如孟子会一点点编程的话, 那么他一定会想说: 

\begin{quotation}
  \begin{minted}{ruby}
    class Human
      @@common_character = :kind_heart
      def initialize(name)
        @name = name
      end
    end
  \end{minted}
\end{quotation}

那么对每个\mintinline{ruby}{Human.new("张三")}以及\mintinline{ruby}{Human.new("李四")}, 那么在上面的代码中, 所有的\textbf{Human}类的对象都共同拥有一个变量名字叫做\textbf{common\_character}, 也就是每个人都应该有的共同的品质都是一颗不忍人之心. 但是每个Human类的对象, 也就是每个人可以有不同的\textbf{name}(名字). 

可能你觉得有点奇怪, 这两个变量和我们之前的变量有什么区别呢? 不就是变量名字前面多了一些奇怪的前缀 -- 没错, 就只是这样, 在形式上的前缀标志就表示了变量的"类型". \footnote{这个类型不是像String, Integer之类的值的类型, 而是全局变量, 类变量, 实例变量, 局部变量等等的变量类型. } 

你可以这样想: \footnote{我在这里只会简单定性地介绍, 暂时不会深究这些变量的具体实现. 建议你先是知道有这么个东西, 然后在之后我们会从一些比较基本的方向来介绍. } 

前面的全局变量(global variable), 因为它们前面拿着一个美刀符号(\$), 于是所向披靡, 在各个地方都是适用的. \footnote{和\textbf{local\_variables}的方法一样, 我们可以通过\textbf{global\_variables}这个方法来得到我们进程中的全局变量. 比如说在一个全新的irb里面, global\_variables方法的返回值为\mintinline{ruby}{[:$VERBOSE, :$-v, :$-w, :$-W, :$DEBUG, ...]}}

对于前面带了一个艾特号(@)的实例变量(instance variable), 你不妨把这个符号想象成一个小小的回形针, 轻轻地别在我们的实例对象(instance object)\footnote{等等, 你是不是想问我什么是实例对象? 其实这个就是我们之前一直说的对象啦. 只不过实例对象的这个名字更加注重强调对象是某个类的对象. 这个是一个叫做面向对象编程的思想的概念, 不过我建议您还是}上, 对象走到哪, 就带着这个实例变量来到哪里, 也就是说, 实例变量的作用区域就是我们的这个实例对象. \footnote{同样的, 你也可以\textbf{instance\_variables}来访问当前的对象的实例变量. 比如\mintinline{ruby}{Human.new("Lucky").instance_variables}就会返回\mintinline{ruby}{[:@name]}的结果. }

而前面有两个@@符号的类变量(class variable), 除了和实例对象相连以外, 还和类(class)\footnote{类其实也是一个对象, 在Ruby里面. }相连. 所以只要是同一个类的实例对象, 那么它们就都共同分享着同样的类变量. \footnote{没错, 你没猜错我们还是能够用简简单单的一个method来访问类的变量, 就决定是你啦: \mintinline{ruby}{Human.class_variables}, 这条命令的返回结果就是\mintinline{ruby}{[:@@common_character]}. }

对于那些普普通通的变量(local variable), 没有任何的前缀, 只能够在一个小小的区域里面随风飘扬. 不过对于代码块之类的在局部查找变量的东西, Ruby还是能够找到它们的. 然而一旦你换到了一些新的区域的时候, 我们就不知道该怎么找到他们了. 

这个并不是Ruby真正的实现方法, 但是假如我们想要实现一个类似的储存变量的方法的话. 这里提供一个简单的想法: 假如我们学过一点点物理的话, 我们就会想到, 嘿, 所有的参考系都应该是平等的, 好像没有什么"绝对"参考系吧. 所以要确定一个物体的位置, 我们总是要去寻求相对位置来找到. 同样的, 我们可以利用相对位置来实现变量的引用, 比如假如我们的区域是一张表格: 

\begin{figure}[h]
  \centering
  \includegraphics[width=\textwidth]{image/chapter/1_language/ruby_variables.jpg}
  \caption{Ruby的变量们}
\end{figure}

当我们想要访问一个变量的时候, 我们就会在当前所在的命名空间里面去寻找, 除非是看到了用\$号开头的全局变量, 才会去约定的地方去寻找. 而我们的实例变量则是相对着实例对象来找的. \footnote{这也就是为什么你会常常看到Ruby里面有类似于有\mintinline{ruby}{object.instance_variable_name}的玩意啦. }而类变量则相对着类来寻找. 这里我们就体现了一种寻找变量值的想法啦. \footnote{具体的话, 我们会在之后再进行一个介绍, 如果可以的话, 我们没准还能实现一个呢. } 这里的寻找变量的方式就是一种相对位置的想法啦. 

那么总结一下

嗯, 我们关于赋值的问题就介绍到这里. 接下来, 让我们抛开赋值的这些乱七八糟的约定. 可以发现, 我们的赋值的操作让我们能够将值和(变量)名字联系在一起, 只需要呼唤名字, 就能够调用原来的值. 或者是更新, 替换, 修改原来的值. 比如: 

\begin{quotation}
  \begin{minted}{ruby}
    string = "I'm the King of the "
    string = string + "Nuts"
    string
    # => "I'm the King of the Nuts"

    string.upcase
    # => "I'M THE KING OF THE NUTS"
    string.downcase
    # => "i'm the king of the nuts"

    my_money = 100
    price_of_cookie = 10
    my_money -= price_of_cookie
    my_money
    # => 90
  \end{minted}
\end{quotation}

这样我们就得到了存放数值的能力, 并且也可以用一个名字来抽象地调用这个值, 从而实现更加强大的功能. 可惜我比较笨, 这里就写一个很普通的利用存放数值的特性交换的例子来结束我们的这一小节吧: 

想象一下, 一个莫得感情的杀手, 为爱杀了人, 从此浪迹天涯, 流落他乡. 一个小女孩委托人, 泥沟里翻滚的父母将她的命运拖入了深渊, 渴求着复仇的她委托杀手替她报仇. 看着小女孩, 杀手的心松动了, 警醒让他明白这样的后果, 人性让他走向了那没有回头路的灭亡之路. 所以他把自己的积蓄留在了线人那里. 他知道自己终将失去, 只是希望至少能够让那个小女孩能够拥有自由的生活. 于是他用自己的至宝与小女孩的一无所有交换, 

\begin{quotation}
  \begin{minted}{ruby}
    leon = "Leon's Treasure"
    mathilda_lando = "Nothing"

    old_tony = leon
    leon = mathilda_lando
    mathilda_lando = old_tony
  \end{minted}
\end{quotation}

上面的代码我们就利用了一个存放数据的概念来做了一个交换, 一开始, 两个变量手中有着各自的值. Léon将自己的值交给了中间人Old Tony, 然后拿起了Mathilda Lando的值. 而Mathilda Lando则从中间人那里拿到了Léon曾经的值. 于是交换过程结束. 我们利用了一个中间变量来实现了两个变量之间值的转换. \footnote{虽然我们还有更多的转换方法, 其中Ruby提供了一个非常酷的方法: \mintinline{ruby}{leon, mathilda_lando = mathilda_lando, leon}, 不过这个代码的背后也有中间变量. 不过是Ruby自动为我们生成的. 为了理解这个, 我们还有一些路要走(因为我不打算接下去将数值类型), 所以放在脚注里面. }

% \subsection{高速吟唱魔法咒语的什么的真是受够了}
% 想象一下人头攒动的庙宇中烟雾缭绕, 本就昏暗的庙堂因此更加声明而难以看清四周. 身边传来楠楠的祷告声, 人们念着自己的心愿. 台上的法师的言语穿过烟雾和人声, 更加得遥远和神秘, 本就听不清楚的祷告声变得更加的让人迷幻了: \footnote{这一篇我打算以传统的祈雨仪式为例子. (原因是因为之前看到了一篇韩愈的祈雨文, 可惜不知道叫什么了. 后来找到了杜牧的祭文. 本来想要删掉的, 因为太多了, 最后我觉得还是保留下来吧. 还有一本专著叫做《從人間世到幽冥界: 唐代的法制, 社會與國家》不过没有看过. ) 只是在网络上搜索相关的资料发现简直是寥寥无几, 并且也没有很详细的介绍. 大多是那种概括性的文字, 果然还是应该要找到那种一手资料吗. 不过通过这次的尝试, 我发现了自己的不足了. 果然还是缺少一些积累吗. }
% 
% \begin{quotation}
%   下土之人, 天實有之. 五穀豐實, 寒暑合節, 天實生之. 苗房甲而水湮之, 苗秀好而旱莠之, 饑即必死, 天實殺之也. 天實有人, 生之孰敢言天之仁, 殺之孰敢言天之不仁. 刺史吏也, 三歲一交. 如彼管庫, 敢有其寶玉；如彼傳舍, 敢治其居室? 東海孝婦, 吏寃殺之, 天實寃之, 殺吏可也. 東海之人, 於婦何辜, 而三年旱之? 刺史性愚, 治或不至, 厲其身可也, 絕其命可也！吉福殃惡, 止當其身. 胡為降旱, 毒彼百姓? 謹書誠懇, 本之於天, 神能格天, 為我申聞. 
% 
%   \emph{杜牧《祭城隍神祈雨文》}\footnote{对不起杜牧先生, 我拿你的文字来作为例子了. 但是前面引入例子的文字实在是写得一般了. \\ 我在\href{https://m.djol.org/show-34-11627-1.html}{网络(不过建议还是不要访问, 因为看起来不正规)}上找到了一个比较像是的东西, 但是我觉得还是不如杜牧的好: \\
%   伏以. 玄穹高上玉皇大帝并雷公, 电母, 风伯, 雨师四大雨神. 兹为**流域祈求甘霖缓解旱情而文. 雨神居上阙而管下界之水, 黎民居下界而仰上京之神, 上神赐福于黎民, 则黎民敬仰上神, 上神无视于黎民, 则黎民不信上神. 上下相关, 神民相依也. 尝曰：民以食为天, 食以粮为主, 粮以水为本. 无粮则人不存, 无水则粮不生. 今春以来, 上苍惜雨, 下界无流, 大河缩萎, 小河干涸, 田地豁裂, 庄稼枯黄, 江汉流域, 尤为其甚. 早稻因无水而少插, 中稻因无水而损苗. 时下已是中稻移栽旺季, 斯地依然干旱少雨, 无水整田. 百姓惶惶, 仕宦忧忧. 今弟子施惠奏明太上, 获准向天庭求雨, 以解斯地旱情, 保中稻栽插, 解燃眉之急, 润十方之农田, 更润百姓之心田. 恳望玉帝并四大雨神, 三日之内, 为上述旱区普降甘霖. 则百姓感上神之大恩, 三界记上神之大功. **道人 顿首叩拜}
% \end{quotation}
% 
% 概括一些就是: 
% 
% \begin{quotation}
%   乞雨女郎魂, 炰羞洁且繁. 庙开鼯鼠叫, 神降越巫言. 
% 
%   旱气期销荡, 阴官想骏奔. 行看五马入, 萧飒已随轩. 
% 
%   \emph{韩愈《郴州祈雨》}
% \end{quotation}
% 
% \begin{quotation}
%   汤既克夏, 大旱七年, 洛川竭. 汤乃以身祷于桑林, 剪其发, 自以为栖牲. 祈福于上帝. 于是大雨总至, 洽于四海. 
% 
%   \emph{《搜神记·变化篇》}
% \end{quotation}
% 
% 你看, 我们可以用一些非常简明的文字来表述那些复杂的事情. 仅仅通过概念来感受这样的祈雨的氛围. 甚至这种仅仅通过概念来传递表示的能力能够超越时空, 哪怕是自己可能从来没有类似的体验的东西, 也能够通过概念的方式来理解和传递. 这里就是一种抽象的概念. \footnote{什么是抽象呢? 举个例子, 假如你的同桌搞了一支很有意思的自动铅笔, 然后借给你看看, 你抚摸着笔的外壳, 比较光滑; 笔握部分的橡胶也比较舒服; 出芯和书写也非常的快乐. 这个时候, 你是通过感官的表象来感受认识"笔"的. 但是有些时候, 你却并不能够直接通过直观或者感官来直接感受, 就像我现在是通过文字来间接的触动你的神经来产生对那支笔的认识. 这个时候就出现了一种抽象的感觉 -- 即我们不再是通过表象, 而是抽象的概念来认识一个东西了. 甚至, 哪怕这只笔已经不复存在了, 甚至只是我臆造的一个概念, 你也能够产生相应的认识. }
% 
% 对于计算机来说, 抽象也是一种非常重要的一种东西. 我们之前其实就已经见识了抽象的一种了: 变量. 我们通过变量这一种抽象的概念, 用变量的名字来抽象地访问一个值. 这个时候, 我们不再是具体地处理数值, 而是通过名字来形式地调用. 
% 
% 这一次, 我们将会不仅仅停留在对数值的抽象, 而是进一步深入, 来看一看更加有趣的对过程的抽象吧. 
% 
% 比方说我们现在有一个非常复杂的过程: (注: 我的目的不是为了分析这个又臭又长的烂程序, 所以不要计较里面的具体做法和实现. )
% 
% \begin{quotation}
%   \begin{minted}{ruby}
% # 一周有七天
% 7.times do |day|
%   # 每天十一节课
%   11.times do |index|
%     # 在网页中找到那一节课的信息
%     box = file.xpath("//tbody/tr[#{index + 1}]/td[#{day + 1}]/div/a")
%     # 假如这节课不是空的
%     unless box == []
%       # 有时候同一节课的时间会有不同的课
%       box.each do |item|
%         # 得到课程的链接
%         link = item.xpath("@href").text
%         # 得到课程的信息
%         course_data = get_info(link, day)
%         # 对于相应的课程
%         course_data[:opening_week].each do |week|
%           # 计算日期, 还有其他一堆东西
%           date = start_date + 7 * (week.to_i - 1) + day
%           the_year = date.year
%           the_month = date.month
%           the_day = date.day
%           sthour = TIME_MAP[index][0][0]
%           stmin = TIME_MAP[index][0][1]
%           edhour = TIME_MAP[index][1][0]
%           edmin = TIME_MAP[index][1][1]
%           # 往日历中加入课程的信息
%           cal.event do |event|
%             event.dtstart = DateTime.civil(the_year, the_month, the_day, sthour, stmin)
%             event.dtend = DateTime.civil(the_year, the_month, the_day, edhour, edmin)
%             event.summary = course_data[:summary] + "-" + course_data[:location]
%             event.alarm do |alarm|
%               # alarm.summary = "Go To Class!"
%               # 提前提醒
%               alarm.action        = "AUDIO"
%               alarm.trigger       = "-PT#{BEFORE_MIN}M"
%               alarm.append_attach "Chord"
%             end if BEFORE_MIN != 0
%           end
%         end
%       end
%     end
%   end
% end
%   \end{minted}
% \end{quotation}
% 
% 这实在是太麻烦了, 所以我只是选择了其中的最复杂(无聊)的部分. \footnote{并且我选择了一个非常烂的代码. 这是进入大学之后我写的一个根据课表自动生成iCalender可以使用的日历文件的程序, 当时的编程经验比较缺乏, 所以我写得非常的脏. 不过刚好, 可以作为一个复杂的直接的过程用简单的抽象来实现的东西的例子. }
% 
% 假如说我们每一次使用这样的代码, 也就是要把一个网页上的课表变成自己iCalender里面的日历文件需要如此这般的复杂过程, 我们估计就会对计算机这样的家伙心生畏惧并且产生一种极其悲观的无力感. 这也就是为什么我们在面对某些技术的时候, 我们会不再想要保持思考, 反而是低下头来臣服于此. 于是尴尬的一幕出现了, 表面上我们都知道, 人类发明了计算机, 计算机是人类智慧的结晶; 但是面对计算机, 我们却常常会说, 啊, 这个东西太复杂了, 所以我不能够理解. 
% 
% 但是对我来说, 我认为其实复杂并不是

\section{理论法师也要会近战暴击}
\begin{quotation}
  但甘道夫快步跃上台阶, 他盛怒而来, 犹如一道白光陡然照进黑暗之地, 那些人急忙遮着自己的眼睛往后退开. 他抬手就是一击, 德内梭尔的剑应声脱手而飞. 

  \emph{《魔戒III-王者归来》}\footnote{摘自\href{https://lotr.huijiwiki.com/wiki/FAQ/甘道夫为什么战斗时不用法术？}{甘道夫为什么战斗时不用法术}, 我对魔戒系列读的不多, 大概只看过第一部电影. 之后会尝试读完这个系列的. }
\end{quotation}

作为一名称职的法师, 除了法攻之外, 物理攻击也是不能缺少的. 而作为一名和计算机无关的外行人, 除了会一点点理论知识, 实操也是不能缺少的. 而所谓实操, 也并不一定是要写个一万行代码\footnote{虽然这样也确实很重要, 我的离散数学老师说, 搞计算机的不写个几十万代码都不好意思说自己是搞计算机的. 但是好像也不是那么重要, 我们的物理班主任说, 学好了统计力学, 对深度学习那套理论就比只会调包的写代码的强了. \\说到底, 这个就是一个实践和理论的矛盾的区别了. 不过这个有什么好争论的呢? 小孩子才做选择, 成年人应该两个都要. }之类的. 

在后面的部分, 我要来介绍一点点我用过的在编写代码的过程的时候遵守的一些规范和用过的一些工具. 虽然只有一点点, 因为其实我编写的代码数量真的不太够. 

\subsection{六芒星的内角是60${}^\circ$, 不是36${}^\circ$}
\begin{quotation}
  有匪君子, 如切如磋, 如琢如磨. 

  \emph{《诗经.卫风.淇奥》}
\end{quotation}

对于那些精妙的语言, 我们赞美它们是"诗一般的语言". 诗有诗歌的格律和形式, 闻一多在《诗的格律》\footnote{一个可能的观看渠道: \href{http://www.guoxue.com/wk/000461.htm}{诗的格律}. 网上找的资料, 并不一定靠谱, 还请仔细鉴别. }中提出过"三美"主张: "音乐美, 绘画美, 建筑美". \footnote{在上面的资料里面, 并没有严格且明确地提出过这样的说法. 应该是后人有对其整理和解读的结果. (不过也有可能是我看漏了) 下面的说法我是从\href{https://www.zgbk.com/ecph/words?SiteID=1&ID=88126&Type=bkzyb&SubID=44490}{诗歌三美 - 中国大百科全书}找到的一个说法, 我觉得应该是算比较权威的一个资料来源了. 之后的分析将会其中的文字解释为依据. } 其中"音乐美"是指音节上的音尺, 平仄与韵脚; "绘画美"是指迟早上的浓密, 鲜明与色彩感; "建筑美"则是"有节的匀称, 有句的匀齐". 

而在编程中, 我们并非是要做一个没有情感的Ctrl-C\&V机器, 也不该做一个混乱无序的"反正能跑"的搬砖工. 而应该向往着写出诗一样的代码. 于是我们也需要追求代码上的"音乐美, 绘画美, 建筑美": 
\footnote{如果你愿意的话, 试试看阅读一下这个\href{https://rubystyle.guide}{文档}, 如果不是那么有空的话, 可以粗略地阅读其中的\href{https://rubystyle.guide/\#introduction}{引言}部分. 一个叫做\href{https://github.com/rubocop/rubocop}{rubocap}的ruby gem工具可以帮助你检查代码是否符合规范. 虽然默认的规则非常严格, 一般是自己定义一些比较宽松的规则. 下面的介绍是部分基于这里面的说明的. yige }

\begin{itemize}
  \item "音乐美": \footnote{说实话, 这段我不知道该怎么讲. 音尺? 平仄? 韵脚? 在代码里面? 这也太扯蛋了. } 如果你学过, 或者看过那些满满翻译腔的数学教材的话. 你估计对下面的句子可能会影响深刻: "A是那样的A, 如果对这样的A, 所有的... ". 虽然难以说这样的东西是好是坏, 但是既然我们阅读是线性的阅读, 遇到跳跃性的代码, 或者说是那种大喘气的代码, 应该都是我们不愿意看到的结果. 
  
  举个例子: 

  \begin{quotation}
    \begin{minted}{ruby}
      10.times do |i|
        # 这样的形式并不是一个好的形式
        # 对人的阅读并不友好
      end if condition
    \end{minted}
  \end{quotation}

  上面的代码虽然和\mintinline{ruby}{10.times {|i| } if condition}是一致的, 但是因为上面的代码却不具备可读性, 而写成一行却具有可读性, 那么区别是什么? 答案是计算机执行的顺序和人阅读的顺序在这里恰好相反, 我们在阅读的时候, 往往是最后才能够看到条件\mintinline{ruby}{condition}, 而计算机则是先计算了条件, 然后再判断是否运行前面的代码块. 在写成一行的时候, 一定程度上我们可以瞥见\mintinline{ruby}{if}关键词, 但是写成多行之后, 便很容易忽略条件而导致失误. 这样的话我们让本来使代码美观清晰的语法糖变成了未来让自己掉进坑里面的危险了. 

  而为了让代码和谐有律, 所以我们需要在代码中掌握编码的节奏. 将一个大的乐章拆解成小的片段. \footnote{忘了是哪个编程大佬说的了(或者可能干脆只是一个笑话): "我讨厌比我头还要长的代码". 并且在rubocup中, 默认的设置甚至变态到对超过20行的块都会提醒修改. (虽然我不建议那么极端, 因为我做不太到)}
  \item "绘画美": 词藻, 在编程语言中可能看似是一个毫不相关的事物. 而更应该像是代码的一种自解释的能力 -- 一种看到代码就能够理解其本身的直观性和易读性. 
  
  比如说, 在Ruby中, 我们有\mintinline{ruby}{if not}和\mintinline{ruby}{unless}, 前者与后者在功能上是一致的, 但是在表意上后者却更加优秀: \mintinline{ruby}{puts x unless x.even?}和\mintinline{ruby}{puts x if not x % 2 == 0}相比, 易读性和直观性便一目了然了. 

  又或者是在为对象选择名字的时候, 不是选择\mintinline{ruby}{var_1}或者是\mintinline{ruby}{var_a}这样不明所以的名字, 而是选择像\mintinline{ruby}{even?}或者\mintinline{ruby}{strip!}或者\mintinline{ruby}{switch_off_light}等的有意义的名字. 

  于是我们在编程的时候, 实际上就像是一个月下独酌的诗人, 在映着月光的角杯中挑选出合适的词句来组织自己的程序. 
  \item "建筑美": \footnote{注意, 这个建筑美不是指\href{https://en.wikipedia.org/wiki/International_Obfuscated_C_Code_Contest}{IOCCC}比赛里面的ASCII艺术. }形式和符号虽然并不直接具有意义\footnote{除了像python这样的把形式焊死, 防止你因为耍小聪明来把自己给坑害了. }, 但是根据形式和符号的组合, 却能够表达关系和意义. 
  
  举个例子: 

  \begin{quotation}
    \begin{minted}{ruby}
      # 可以运行, 但是在形式上却让人难以理解
      # 甚至可以说令人作呕
      10.times do |i|
      (0...2).each { |j| (0..1).to_a.each do |k|
      puts i *j**k-  i*j ** (k-1)
      end}
      end

      # 下面这样就会容易理解
      # 并且明显可以看出有代码块结构
      10.times do |i|
        2.times do |j|
          2.times do |k|
            puts i * j**k - i * j**(k - 1)
          end
        end
      end
    \end{minted}
  \end{quotation}

  于是我们发现, 一个漂亮的结构形式有助于让我们能够一眼看清代码的相互关系. 也就是说, 我们在代码中应当追求的建筑美是一种通过合理的格式化代码达到的"一眼知"结果的效果. \footnote{那么具体要如何做呢? Ruby其实并没有一个像python的\href{https://peps.python.org/pep-0008/}{PEP}官方规范, 也没有像python一样, 如果不遵守的话就会爆炸的缩进约定. 所以Ruby可以有各种各样的写法, 但也导致了容易把代码写得很乱. \href{https://github.com/ruby-formatter/rufo}{rufo}是一个可以使用的gem, 但是并不是说其就是完美的答案, 因为Ruby给了你选择的能力, 所以请再试试看如何写出诗一样的代码吧. \\不过也不要沉迷了, 毕竟我这本书并不是一个Ruby的教材, 使用Ruby来教学完全是出于我个人的恶趣味. (不是), 是为了给你一个不太一样的起点. }
\end{itemize}

\subsection{魔导书阅读入门}
\begin{quotation}
  自己场上有魔法师族怪兽存在的场合, 把这张卡以外的手卡1张名字带有「魔导书」的卡给对方观看, 选择「创造之魔导书」以外的自己墓地1张名字带有「魔导书」的通常魔法卡才能发动. 这张卡的效果变成和选择的通常魔法卡的效果相同. 「创造之魔导书」在1回合只能发动1张. 

  \emph{创造之魔导书, 来源于\href{https://zh.moegirl.org.cn/创造之魔导书}{萌娘百科}}
\end{quotation}

大概在我很小的时候, 《游戏王》在我们那块还很流行, 就一个小盒子, "财力雄厚"的小孩可以把一个小鞋盒一般的盒子填满. \footnote{或者是那个时候常常会见到的那种类似于图鉴的东西. 在新华书店上的书架上面, 排放着那些色彩鲜艳的图画书, 这是多么吸引人啊. }那些卡片大概是这样的: 

\begin{figure}[h]
  \centering
  \includegraphics[width=0.75\textwidth]{image/chapter/1_language/magic-card.png}
  \caption{嗯嗯, 召唤皮皮怪! 使用技能"摆烂"! }
\end{figure}

一张漂亮的图片, 一个好听的名字和一段详细的介绍. 这段介绍里面详细地说明了这个名字所代表的对象的功能和使用方法. 于是我们只要按照卡片上说明文字就能够发挥卡片的功能. 毕竟一个合格的魔法师, 不会阅读魔导书, 又怎么能够召唤恶魔和妖精来为自己服务呢? 

于是就像是这样, 如果我们想要了解和指挥那些计算机里面的小精灵, 也需要查阅"魔导书" -- 也就是阅读文档来更好的了解如何使用或者更好地编写程序. 这样的文档就像是诗人们的典故的引用宝典, 值得推荐的Ruby相关的文档有: 

\begin{itemize}
  \item \href{https://ruby-doc.org}{Ruby-Doc.org}
  \item \href{https://www.rubydoc.info}{RubyDoc.info}
  \item 或者是\href{https://www.ruby-lang.org}{Ruby-lang}里面的\href{https://www.ruby-lang.org/en/documentation/}{Documentation}部分. 
\end{itemize}

以Ruby-Doc.org为例, 我们可以在主界面选择相关的Core API(核心API)的文档. 以我所用的\href{https://ruby-doc.org/core-3.0.0/}{3.0.0 core}为例, 可以查看里面一些核心的Class(类), Methods(方法)等等. % 以其中的文件读写\href{https://ruby-doc.org/core-3.0.0/File.html}{File}类为例: 

% \begin{quotation}
%   A \mintinline{ruby}{File} is an abstraction of any file object accessible by the program and is closely associated with class \mintinline{ruby}{IO}. \mintinline{ruby}{File} includes the methods of module \mintinline{ruby}{FileTest} as class methods, allowing you to write (for example) \mintinline{ruby}{File.exist?("foo")}...
% \end{quotation}
% 
% 而通过Methods侧栏能够了解类中的方法, 以其中的\href{https://ruby-doc.org/core-3.0.0/File.html#method-c-new}{new}方法为例: 
% 
% \begin{quotation}
%   \begin{minted}{ruby}
%     f = File.new("testfile", "r")
%     f = File.new("newfile",  "w+")
%     f = File.new("newfile", File::CREAT|File::TRUNC|File::RDWR, 0644)
%   \end{minted}
% 
%   Opens the file named by filename according to the given mode and returns a new \mintinline{ruby}{File} object.
% \end{quotation}
% 
% 于是这样就能够了解如何打开一个文件, 以及继续阅读就能够知道如何对文件有一个更好的操作. 

以\href{https://ruby-doc.org/core-3.0.0/Regexp.html}{Regexp}类为例, 在开头会有对这个类的相应的介绍文字, 就像是一篇文章的导读和摘要一样, 通过阅读这些文字可以对相应的类有相应的总体的了解: 

\begin{quotation}
  A \mintinline{ruby}{Regexp} holds a regular expression, used to match a pattern against strings. Regexps are created using the \mintinline{ruby}{/.../} and \mintinline{ruby}{%r{...}} literals, and by the \mintinline{ruby}{::new} constructor... 

  \begin{minted}{ruby}
    /hay/ =~ 'haystack'   #=> 0
    /y/.match('haystack') #=> #<MatchData "y">
  \end{minted}
\end{quotation}

于是我们能够对这样类有一个基本的概略性的了解和认识. \footnote{并且更加厉害的是, 这个Regexp真的讲得超级详细, 基本上可以说是可以代替正常的教材了, 至少我是看这个学的正则表达式. 红红火火吼吼吼吼. }如果稍微更加仔细地阅读一下, 就能够稍微更加了解里面的东西的意义和使用方式了. 

\begin{example}
  请使用正则表达式, 将输入的一串字符串中的数字反向掉转, 比如像这样: 

  \begin{minted}{ruby}
    str = "a number is 123 and another one is 23333. "
    reverse_num(str)
    # => "a number is 321 and another one is 33332. "
  \end{minted}

  那么请查阅文档吧, 让我们的魔导书的书页翻动起来吧! \footnote{答案? 我不会告诉你的\\\mintinline{ruby}{-> (str) { str.gsub(/\d+/) { |m| m.reverse }}}\\好吧, 我留下了答案咯. }
\end{example}

好耶! 现在我们就能够通过翻阅文档来了解那无限宽广的世界了. \footnote{并且, Ruby的Rdoc还支持通过代码中的注释来自动生成文档, 于是我们在使用gem的时候可以通过阅读这些文档来了解如何使用它们. 不过目前这并不是我想要介绍的重点. 如果想要了解的话, 请参考这个\href{https://li-yiyang.github.io/ruby/why's_(poignant)_guide_to_ruby/why's-poignant-guide/}{翻译}}

\section{还能够去看什么? }
\begin{itemize}
  \item 《屠龙之技》 长铗\footnote{原始的出处应该是09年第2期的《科幻世界》, 但是因为时间不够, 所以没法找到原始的出处. 这里提供一个看起来还算是比较官方的\href{https://www.zhihu.com/xen/market/remix/paid_column/1439565482748272640}{链接}. 不过如果是穷学生的话, 我不能说你不能够在网络上看到相应的文字. \\这是一篇科幻小说, 我写这段文字的时候刚看的, 感觉有一种浪漫的情怀. 虽然里面可能不能够教会你什么东西, 并且里面充斥着很多的术语和名词. }
  \item SICP (Wizard Book) \footnote{这个我认为是一本很好的书, 虽然我并没有完全地读完, 并且读的时候甚至也没有任何的练习. 所以如果以后有时间的话, 我打算重新认真地阅读这本书. \\之所以推荐这本书, 某种程度上来说是因为这本书刷新了一开始我的朴素的编程思想观念. 并且我认为这本书不论什么阶段去阅读, 都会有一个很好的理解. (虽然我还没有经历过高级阶段, 只是在低级阶段徘徊. )\\这本书你可以在\href{https://mitpress.mit.edu/sites/default/files/sicp/index.html}{网络}上看到. 中文版的话应该也有, 不知道中文的网页版的有没有. }
  \item why's (poignant) book for ruby\footnote{\href{https://poignant.guide}{链接}. 可能这个就是我真正想要学编程的一个契机吧, 稍微夹带了一些自己的私货了属于是. 不过如果想要速成Ruby的话, 建议去看官网的\href{https://www.ruby-lang.org/en/documentation/quickstart/}{Ruby in Twenty Minutes}, 如果想要非常实用的开发的话, 建议去找一本好用的书. (虽然我个人并不觉得在实际场景里面, Ruby的竞争力如何, 毕竟残酷的现实是: Ruby在Rails以外好像没有特别能打库. 这一点Python之类的优势十分明显. )\\但是本书并不是一个Ruby的教程, 所以不用担心学不会Ruby. 因为我的想法是: 有啥用啥, 用啥学啥. }
  \item Ruby Koans\footnote{\href{http://rubykoans.com}{Ruby Koans}中有很多的Ruby代码的例子, 和Ruby Cookbook类似, 不过更注重基本知识的介绍和应用. }
  \item Ruby Cookbook \footnote{\href{http://www.oreilly.com/catalog/rubyckbk/}{动物出版社}出品. 虽然对于穷学生, 我不会说这个在网络上是可以找到的. 不过可以的话, 还是请支持正版. \\这本书里面介绍了很多的Ruby编程的小技巧, 适合闲暇时间看看, 但是不适合认真阅读. 说白了就是一本字典. }
  \item ...\footnote{可以读的书还是挺多的. }
  \item Magic the Book | 标题还没想好·阿姆斯特朗回旋加速喷气式阿姆斯特朗炮使用手册 \footnote{没错, 就是这本书. 好吧, 感觉有点王婆卖瓜自卖自夸了. }
\end{itemize}